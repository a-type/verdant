"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6065],{8784:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"internals/initial-sync","title":"Initial sync","description":"When a replica comes online, it must exchange information with the server until they share a common understanding of the operation history of the library in question.","source":"@site/docs/internals/initial-sync.md","sourceDirName":"internals","slug":"/internals/initial-sync","permalink":"/docs/internals/initial-sync","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"How it works","permalink":"/docs/category/how-it-works"},"next":{"title":"Protocol assumptions","permalink":"/docs/internals/assumptions"}}');var a=i(1273),s=i(8576);const r={sidebar_position:1},o="Initial sync",l={},c=[{value:"A replica is not the first to initialize a new library",id:"a-replica-is-not-the-first-to-initialize-a-new-library",level:2},{value:"A replica goes &quot;truant&quot; and then reconnects",id:"a-replica-goes-truant-and-then-reconnects",level:2},{value:"A replica has lost its local data store",id:"a-replica-has-lost-its-local-data-store",level:2}];function h(e){const t={em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"initial-sync",children:"Initial sync"})}),"\n",(0,a.jsx)(t.p,{children:"When a replica comes online, it must exchange information with the server until they share a common understanding of the operation history of the library in question."}),"\n",(0,a.jsx)(t.p,{children:"A naive approach would be to have the replica send over any changes it made since the last time it saw the server, and for the server to respond with any changes it received in the same time interval. And this, in fact, gets us very far."}),"\n",(0,a.jsx)(t.p,{children:"However, there are a few contingencies to consider which require more robust protocols. In fact I'm writing this document to define and explore those before implementing said protocols, as a thought exercise."}),"\n",(0,a.jsx)(t.h2,{id:"a-replica-is-not-the-first-to-initialize-a-new-library",children:"A replica is not the first to initialize a new library"}),"\n",(0,a.jsx)(t.p,{children:"Suppose replicas A and B are both attempting to sync, for the first time, to a brand new Library 1. A gets there first, so the server receives and copies A's local history into its own database."}),"\n",(0,a.jsxs)(t.p,{children:["When B arrives, what should happen? B and A have entirely separate and theoretically irreconcilable histories. We could ",(0,a.jsx)(t.em,{children:"attempt"})," to merge them, but Verdant's assumption is that this could cause more harm than good."]}),"\n",(0,a.jsx)(t.p,{children:"Instead, the server will ignore B's incoming data and respond with its full storage, instructing B to reset its local state instead."}),"\n",(0,a.jsx)(t.p,{children:"This means that if you write an app which optimistically chooses a library ID and tries to push local data to that library, it may end up with all your local data being lost!"}),"\n",(0,a.jsx)(t.p,{children:"Instead, joining a library should be a very explicit action that the user consents to, and your app should be designed such that the only the first user to be given access to a library is under the assumption their data will be utilized. Subsequent joiners should be informed that their local changes will be lost."}),"\n",(0,a.jsx)(t.h2,{id:"a-replica-goes-truant-and-then-reconnects",children:'A replica goes "truant" and then reconnects'}),"\n",(0,a.jsx)(t.p,{children:"This is actually the same as the previous case! A replica used to be part of a library but hasn't been seen in so long that the server has kicked it out. When it reconnects, local changes are forfeit."}),"\n",(0,a.jsx)(t.h2,{id:"a-replica-has-lost-its-local-data-store",children:"A replica has lost its local data store"}),"\n",(0,a.jsx)(t.p,{children:"In theory, we'd see this crop up if the user cleared site data - like, the server would think it's seen the replica before, and only catch it up on recent changes, leading to incomplete history."}),"\n",(0,a.jsx)(t.p,{children:"However, it doesn't actually happen, because the replica ID is also stored alongside operations and baselines. So when a user clears the storage, the replica reconnects as a new identity, and receives the full history in return."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8576:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var n=i(3917);const a={},s=n.createContext(a);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);