"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9438],{8384:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sync/tips-and-tricks","title":"Tips and tricks for working in distributed systems","description":"After a year or so of building distributed apps on Verdant, here\'s some tricks I\'ve picked up.","source":"@site/docs/sync/tips-and-tricks.md","sourceDirName":"sync","slug":"/sync/tips-and-tricks","permalink":"/docs/sync/tips-and-tricks","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Access Control","permalink":"/docs/sync/access"},"next":{"title":"CLI","permalink":"/docs/cli"}}');var i=t(7557),r=t(6039);const o={sidebar_position:11},c="Tips and tricks for working in distributed systems",a={},d=[{value:"Using a custom <code>primaryKey</code> for &#39;canonical&#39; documents",id:"using-a-custom-primarykey-for-canonical-documents",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"tips-and-tricks-for-working-in-distributed-systems",children:"Tips and tricks for working in distributed systems"})}),"\n",(0,i.jsx)(n.p,{children:"After a year or so of building distributed apps on Verdant, here's some tricks I've picked up."}),"\n",(0,i.jsxs)(n.h2,{id:"using-a-custom-primarykey-for-canonical-documents",children:["Using a custom ",(0,i.jsx)(n.code,{children:"primaryKey"})," for 'canonical' documents"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"The problem:"})," You have many replicas writing to the same library, possibly offline, but you want a particular document to ",(0,i.jsx)(n.em,{children:"converge"})," when they sync together, even if it was created independently on multiple devices."]}),"\n",(0,i.jsxs)(n.p,{children:["One intuitive example is if you had a music app and you wanted all creations of the ",(0,i.jsx)(n.em,{children:"Rock"})," genre to converge into the same Genre object as multiple people add music and categorize it. (",(0,i.jsx)(n.a,{href:"https://gnocchi.biscuits.club",children:"Gnocchi"})," uses this for Categories and Foods)."]}),"\n",(0,i.jsxs)(n.p,{children:["Instead of using a generated ID for the primary key, you can define it yourself. Even if multiple clients ",(0,i.jsx)(n.code,{children:".put"})," the same document with the same ID, they will all end up sharing a history once sync replicates all changes."]}),"\n",(0,i.jsx)(n.p,{children:"However, because of limitations in Verdant's sync design, the last writer will still 'win' and their initial value will overwrite any prior changes, even if those changes included multiple alterations. In practice this doesn't seem to present a huge problem; most of the time replicas are online and will sync the document instead of creating it themselves."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},6039:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(8225);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);