"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4225],{3816:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"internals/diffing","title":"Auto-diffing","description":"Verdant comes with some moderately sophisticated auto-diffing of nested JSON content. While most of the time you should make specific and intentional changes to data using entity methods like .set, .push, etc, diffing comes into play in two scenarios:","source":"@site/docs/internals/diffing.md","sourceDirName":"internals","slug":"/internals/diffing","permalink":"/docs/internals/diffing","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Entity IDs","permalink":"/docs/internals/entity-ids"},"next":{"title":"Comparisons to other local-first tools","permalink":"/docs/comparisons"}}');var s=i(7557),o=i(6039);const a={sidebar_position:4},r="Auto-diffing",d={},l=[{value:"How diffing works",id:"how-diffing-works",level:2},{value:"Object identity preservation",id:"object-identity-preservation",level:3},{value:"Prevention of moving objects or multiple references to the same object",id:"prevention-of-moving-objects-or-multiple-references-to-the-same-object",level:3},{value:"List heuristics",id:"list-heuristics",level:3}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"auto-diffing",children:"Auto-diffing"})}),"\n",(0,s.jsxs)(t.p,{children:["Verdant comes with some moderately sophisticated auto-diffing of nested JSON content. While most of the time you should make specific and intentional changes to data using entity methods like ",(0,s.jsx)(t.code,{children:".set"}),", ",(0,s.jsx)(t.code,{children:".push"}),", etc, diffing comes into play in two scenarios:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Migrations: when using the ",(0,s.jsx)(t.code,{children:"migrate('collection', ...)"})," tool, the migration function receives a snapshot of the document and returns a migrated plain object. The migration engine then uses Verdant's diffing algorithm to determine what changes to apply for the migration."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:".update"}),": Object entities have a ",(0,s.jsx)(t.code,{children:".update"})," field which accepts a deep object representation to apply to the entire entity. ",(0,s.jsx)(t.code,{children:".update"})," allows full replacement of the object, or a deep merge where new fields overwrite old ones but any untouched fields are retained. Both versions use Verdant's diffing algorithm."]}),"\n"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"Note: for the migrations use case, I'm considering a future update which deprecates diff-based migrations and exposes the same entity tools as the runtime code to enable more intentional migration changes."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"how-diffing-works",children:"How diffing works"}),"\n",(0,s.jsx)(t.p,{children:"The diffing algorithm is fairly complex and tries to produce a minimal changeset, within reason. This means it may make some assumptions which don't match user intention. So, I thought I'd clarify what happens here. All of this behavior is covered in unit tests, too."}),"\n",(0,s.jsx)(t.h3,{id:"object-identity-preservation",children:"Object identity preservation"}),"\n",(0,s.jsxs)(t.p,{children:["Diffing will always make an effort to preserve the identities of sub-objects. Verdant assigns unique identifiers to all sub-objects, so if these identifiers are available for incoming data, it will match up identities and only apply internal changes to these objects instead of replacing them. For example, if you started from ",(0,s.jsx)(t.code,{children:"{ foo: { bar: 1 } }"})," and ended with ",(0,s.jsx)(t.code,{children:"{ foo: { bar: 2 } }"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If the sub-object has retained its Verdant identifier reference, the produced diff will only apply the ",(0,s.jsx)(t.code,{children:"bar: 1 -> 2"})," change."]}),"\n",(0,s.jsxs)(t.li,{children:["If the sub-object has not retained its Verdant identifier, the produced change will assign the root ",(0,s.jsx)(t.code,{children:"foo"})," key to a brand new object, ",(0,s.jsx)(t.code,{children:"{ bar: 2 }"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Obviously the second case is not very efficient, especially if you have large and deeply nested structures. So in addition to attempting to preserve object identity references (which is often brittle and cannot be maintained with user-supplied objects), Verdant also exposes an option to ",(0,s.jsx)(t.code,{children:".update"})," called ",(0,s.jsx)(t.code,{children:"replaceSubObjects"}),". When this is off (default), Verdant will assume any incoming object which has no assigned identity is the same as whatever was already there. By turning this option off, you can instead intentionally produce the second outcome above."]}),"\n",(0,s.jsx)(t.h3,{id:"prevention-of-moving-objects-or-multiple-references-to-the-same-object",children:"Prevention of moving objects or multiple references to the same object"}),"\n",(0,s.jsx)(t.p,{children:"Suppose you did something like this,"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const foo = doc.get('foo');\ndoc.update({\n\tbar: foo.getSnapshot(),\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Naively, this appears to take the ",(0,s.jsx)(t.code,{children:"foo"})," field and assign it to the ",(0,s.jsx)(t.code,{children:"bar"})," key. Since merge is on by default, this would mean this same object is assigned to two keys in ",(0,s.jsx)(t.code,{children:"doc"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Verdant's diffing algorithm does not allow this. Mainly because it would be a footgun in most cases, producing documents with fields that unexpectedly update when 'other' fields change. Verdant assumes that even if you do something like the above, your intention is to create a copy of the same data in the other field. So, it creates the clone for you automatically, initializing it and assigning it a new identity."}),"\n",(0,s.jsxs)(t.p,{children:["Right now there is no way to alter that behavior. So, this prevents not only multiple assignments, but also the movement of a sub-object from one key to another while preserving its identity (note: this is possible with list entities, though, using special methods like ",(0,s.jsx)(t.code,{children:".move"}),")."]}),"\n",(0,s.jsx)(t.p,{children:"If there's a use case for moving objects with preserved identities within objects or maps, let me know with an issue, I can probably make this work."}),"\n",(0,s.jsx)(t.h3,{id:"list-heuristics",children:"List heuristics"}),"\n",(0,s.jsx)(t.p,{children:"Lists are pretty complicated to diff well, and on top of that, the result of a bad diff can be particularly gross. For example, if you had a list diff like"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"[0, 1, 3, 4, 5, 6, 7] -> [0, 1, 2, 3, 4, 5, 6, 7]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["A human can easily grasp that the intention was to just insert ",(0,s.jsx)(t.code,{children:"2"}),". But a naive list diff will instead ",(0,s.jsx)(t.em,{children:"set"})," 2 to the third position, then proceed to erase and overwrite every subsequent value, losing all identities in the process."]}),"\n",(0,s.jsx)(t.p,{children:"The irony here is, diffing is most useful for quick integration with complex document objects like rich text schemas, in which this kind of insertion (say, inserting a paragraph in the middle of a large document) is incredibly common, and where the preservation of item identities is crucial to sane collaboration!"}),"\n",(0,s.jsx)(t.p,{children:"So the diffing algorithm must be a little more smart than that."}),"\n",(0,s.jsx)(t.p,{children:"As of writing this, though, it's still a work in progress. Here are some supported behaviors:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Diffs can detect a single insertion of an item, as long as the items on either side retain their identities. It cannot (yet) detect insertions of ranges of items."}),"\n",(0,s.jsx)(t.li,{children:"Diffs will encode items added past the end of the original list as pushes, not sets."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["These conventions at least allow you to use diffing to insert one new item in the middle of a list, as long as Verdant object identities are preserved. However, this relies on identity preservation, which is a challenge. Verdant's ",(0,s.jsx)(t.a,{href:"/docs/integrations/tiptap",children:"TipTap"})," integration, for example, writes object identifiers to the attributes of all document nodes under the hood, just so it can read them again when changed data is delivered from the editor and reconstruct the identity tree of the document before diffing. But even this is tenuous, and will probably be replaced with non-diff-based change tracking as that integration matures."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},6039:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>r});var n=i(8225);const s={},o=n.createContext(s);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);