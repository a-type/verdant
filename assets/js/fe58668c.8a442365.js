"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9568],{9290:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"comparisons","title":"Comparisons to other local-first tools","description":"Local-first is pretty new on the web, so it makes sense you\'d want to choose carefully when adopting technologies. Clear mass-adoption winners haven\'t really emerged yet, and tradeoffs are everywhere.","source":"@site/docs/comparisons.md","sourceDirName":".","slug":"/comparisons","permalink":"/docs/comparisons","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Auto-diffing","permalink":"/docs/internals/diffing"},"next":{"title":"Efficiency & Performance","permalink":"/docs/efficiency"}}');var n=o(7557),s=o(6039);const r={sidebar_position:8},a="Comparisons to other local-first tools",l={},d=[{value:"Local storage tradeoffs",id:"local-storage-tradeoffs",level:2},{value:"You might like these if:",id:"you-might-like-these-if",level:3},{value:"You might dislike these if:",id:"you-might-dislike-these-if",level:3},{value:"Sync tradeoffs",id:"sync-tradeoffs",level:2},{value:"You might like these if:",id:"you-might-like-these-if-1",level:3},{value:"You might dislike these if:",id:"you-might-dislike-these-if-1",level:3}];function c(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"comparisons-to-other-local-first-tools",children:"Comparisons to other local-first tools"})}),"\n",(0,n.jsx)(t.p,{children:"Local-first is pretty new on the web, so it makes sense you'd want to choose carefully when adopting technologies. Clear mass-adoption winners haven't really emerged yet, and tradeoffs are everywhere."}),"\n",(0,n.jsx)(t.p,{children:"So here's an attempt at a concise and honest summary of tradeoffs in Verdant. Obviously I'll have some bias toward my framework, but really, I built Verdant for me and it doesn't bother me much if you choose something else, so I think you'll find I'm being pretty candid here."}),"\n",(0,n.jsx)(t.h2,{id:"local-storage-tradeoffs",children:"Local storage tradeoffs"}),"\n",(0,n.jsx)(t.p,{children:"Verdant prioritizes:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"\u2b50 Limiting storage usage over time: old changes are compressed and dropped"}),"\n",(0,n.jsxs)(t.li,{children:["\u2b50 Future-proofing and flexibility: ",(0,n.jsx)(t.a,{href:"/docs/local-storage/migrations",children:"Migrations"})]}),"\n",(0,n.jsxs)(t.li,{children:["Safe data usage: ",(0,n.jsx)(t.a,{href:"/docs/local-storage/schema",children:"Schemas"})]}),"\n",(0,n.jsx)(t.li,{children:"Out-of-the-box usage: start storing and querying immediately, no choices to make about persistence layers or conflict resolution choices"}),"\n",(0,n.jsx)(t.li,{children:"Document-based data: no formal relations between objects, but deep nested objects is encouraged"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Those marked with a \u2b50 are choices I think are particularly unique at time of writing in this space. I'm not aware of any other conflict-avoidant, syncing storage which doesn't monotonically grow utilized storage space on-device over time, and I'm aware of very few other solutions for local-first data storage which focus on migrating data as the app changes (for others, see ",(0,n.jsx)(t.a,{href:"https://electric-sql.com/docs/usage/migrations",children:"ElectricSQL"})," and ",(0,n.jsx)(t.a,{href:"https://vlcn.io/docs/cr-sqlite/migrations",children:"VLCN"}),", but IMO neither of these is as easy as Verdant, yet)."]}),"\n",(0,n.jsxs)(t.p,{children:["Verdant ",(0,n.jsx)(t.em,{children:"de"}),"prioritizes:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"\u26a0\ufe0f Query speed: IndexedDB is slow and Verdant isn't particularly optimized, either."}),"\n",(0,n.jsx)(t.li,{children:"Storage adaptability: No alternate persistence options, plugins, or functionality 'hooks.'"}),"\n",(0,n.jsx)(t.li,{children:"Complex queries: only index-based queries are supported, there's no SQL or even a rudimentary dynamic query language. You can do complicated queries, but you'll need to write complicated indexes to make that work. Verdant will eventually force you to do advanced filtering in-memory on a larger result set (remember, all data is already local)."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"you-might-like-these-if",children:"You might like these if:"}),"\n",(0,n.jsx)(t.p,{children:"You're worried about local-first deployment and how it might restrict your ability to pivot your approach to app features or data model in the future while maintaining user data on their devices"}),"\n",(0,n.jsx)(t.h3,{id:"you-might-dislike-these-if",children:"You might dislike these if:"}),"\n",(0,n.jsx)(t.p,{children:"Your app has any specific performance needs (like 60fps multiplayer) and you're not able to rely on technical work-arounds (like pre-loading queries) and slight-of-hand (like cursor interpolation)."}),"\n",(0,n.jsx)(t.p,{children:"You really like SQL and relational models. Although, let me say, I do too... but I found for local-first, documents are actually fairly nice to work with."}),"\n",(0,n.jsx)(t.h2,{id:"sync-tradeoffs",children:"Sync tradeoffs"}),"\n",(0,n.jsx)(t.p,{children:"Verdant prioritizes:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Working on your existing server infrastructure (provided it's NodeJS lol)"}),"\n",(0,n.jsx)(t.li,{children:"Extreme simplicity of deployment model: 1 server, SQLite database"}),"\n",(0,n.jsx)(t.li,{children:"Versatility of network transport: polling or websockets"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Verdant ",(0,n.jsx)(t.em,{children:"de"}),"prioritizes:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"\u26a0\ufe0f Horizontal scaling. User storage libraries would have to be sharded to fit on specific servers. Servers can't talk to one another today."}),"\n",(0,n.jsx)(t.li,{children:"Performance: I haven't scaled anything up much on Verdant so I don't know how many users will fit on a server. I'll probably improve this over time if any of my apps get more users."}),"\n",(0,n.jsx)(t.li,{children:"Variability of storage: you only get to choose where the SQLite database goes. Can't be integrated into another database, can't use Postgres, etc."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"you-might-like-these-if-1",children:"You might like these if:"}),"\n",(0,n.jsx)(t.p,{children:"You already have a Node server and don't want to have to set up much to get started with sync. Or, generally, if you're more focused on building a product than worrying about sync protocols and storage backends."}),"\n",(0,n.jsx)(t.h3,{id:"you-might-dislike-these-if-1",children:"You might dislike these if:"}),"\n",(0,n.jsx)(t.p,{children:"You've got strong opinions about backend systems and databases, or use another language for your backend."}),"\n",(0,n.jsx)(t.p,{children:"Or, if you won't want to host any backend at all (Verdant has no cloud offering)."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},6039:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var i=o(8225);const n={},s=i.createContext(n);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);