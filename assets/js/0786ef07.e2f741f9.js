"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7692],{369:(e,n,a)=>{a.d(n,{xA:()=>c,yg:()=>m});var t=a(7378);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function r(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),d=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},c=function(e){var n=d(e.components);return t.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},y=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(a),y=i,m=u["".concat(s,".").concat(y)]||u[y]||p[y]||l;return a?t.createElement(m,o(o({ref:n},c),{},{components:a})):t.createElement(m,o({ref:n},c))}));function m(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=a.length,o=new Array(l);o[0]=y;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var d=2;d<l;d++)o[d]=a[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}y.displayName="MDXCreateElement"},2775:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var t=a(8084),i=(a(7378),a(369));const l={sidebar_position:1},o="Schema",r={unversionedId:"local-storage/schema",id:"local-storage/schema",title:"Schema",description:"Why have a schema?",source:"@site/docs/local-storage/schema.md",sourceDirName:"local-storage",slug:"/local-storage/schema",permalink:"/docs/local-storage/schema",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Storing & Querying",permalink:"/docs/category/storing--querying"},next:{title:"Generating the client code",permalink:"/docs/local-storage/generate-client"}},s={},d=[{value:"Why have a schema?",id:"why-have-a-schema",level:2},{value:"Creating a schema",id:"creating-a-schema",level:2},{value:"Requirements for a schema",id:"requirements-for-a-schema",level:3},{value:"Requirements for a collection",id:"requirements-for-a-collection",level:3},{value:"Types of fields",id:"types-of-fields",level:2},{value:"<code>&#39;string&#39;</code>",id:"string",level:3},{value:"<code>&#39;number&#39;</code>",id:"number",level:3},{value:"<code>&#39;boolean&#39;</code>",id:"boolean",level:3},{value:"<code>&#39;array&#39;</code>",id:"array",level:3},{value:"<code>&#39;object&#39;</code>",id:"object",level:3},{value:"<code>&#39;map&#39;</code>",id:"map",level:3},{value:"<code>&#39;file&#39;</code>",id:"file",level:3},{value:"<code>&#39;any&#39;</code>",id:"any",level:3},{value:"Indexing Fields",id:"indexing-fields",level:2},{value:"Recursive Fields",id:"recursive-fields",level:2},{value:"Available <code>replace</code> field helpers for recursion",id:"available-replace-field-helpers-for-recursion",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Troubleshooting recursive fields",id:"troubleshooting-recursive-fields",level:3}],c={toc:d},u="wrapper";function p(e){let{components:n,...a}=e;return(0,i.yg)(u,(0,t.A)({},c,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"schema"},"Schema"),(0,i.yg)("h2",{id:"why-have-a-schema"},"Why have a schema?"),(0,i.yg)("p",null,"Verdant requires all data be defined in a schema. That may seem cumbersome, but knowing what data looks like is essential to changing the shape of that data over time as your app evolves. Data lives on user devices, not your servers, so getting migrations right is very important","\u2014","data loss or corruption can be unrecoverable, and no backups exist."),(0,i.yg)("p",null,"Take the time to think about how you model your data and define it in your schema. Mistakes in local-first apps are costly!"),(0,i.yg)("h2",{id:"creating-a-schema"},"Creating a schema"),(0,i.yg)("p",null,"The first step client-side is to define a schema of what kind of documents you are working with. A schema looks like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { collection, schema } from '@verdant-web/store';\n\nconst todoItems = collection({\n    name: 'todoItem',\n    // your primary key must be a field in your collection,\n    // and you must not rewrite it after creating a document.\n    primaryKey: 'id',\n    fields: {\n        id: {\n            type: 'string',\n            indexed: true,\n            unique: true,\n        },\n        details: {\n            type: 'string',\n            indexed: false,\n            unique: false,\n        },\n        done: {\n            type: 'boolean',\n        },\n    },\n    indexes: {},\n    compounds: {},\n});\n\nexport default schema({\n    version: 1,\n    collections: {\n        todoItems: todoItems,\n    },\n});\n")),(0,i.yg)("p",null,"This schema creates 1 document type, ",(0,i.yg)("inlineCode",{parentName:"p"},"todoItem"),", and defines some fields. It also creates the initial default migration to set up this schema in IndexedDB."),(0,i.yg)("p",null,"The TypeScript types for ",(0,i.yg)("inlineCode",{parentName:"p"},"collection")," should enforce proper schema shape, but the docs below explain what each part means."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},"Note: for now I recommend you define collections at the top level, like shown above, or even split them into their own modules. There's a problem with TypeScript typings if you define collections inline inside ",(0,i.yg)("inlineCode",{parentName:"p"},"schema()"),".")),(0,i.yg)("h3",{id:"requirements-for-a-schema"},"Requirements for a schema"),(0,i.yg)("p",null,"Each schema needs a ",(0,i.yg)("inlineCode",{parentName:"p"},"version"),". Whenever a change is made to the schema, the version must be incremented. Otherwise, Verdant will crash with an error."),(0,i.yg)("p",null,"Schemas also have a map of ",(0,i.yg)("inlineCode",{parentName:"p"},"collections"),". These define what kinds of documents are stored in your database."),(0,i.yg)("p",null,"Your schema can be multiple files, but the entry file (which you provide to the CLI) must have a default export which is a ",(0,i.yg)("inlineCode",{parentName:"p"},"schema()"),"."),(0,i.yg)("h3",{id:"requirements-for-a-collection"},"Requirements for a collection"),(0,i.yg)("p",null,"Each collection needs the following:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"name"),": a singular name for the collection."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"primaryKey"),": specify which field name acts as the primary document key. Must be a string or number field."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"fields"),": a map of root fields on the document. See below.")),(0,i.yg)("p",null,"Additionally, you can add complex indexes for querying the collection:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"indexes"),": freeform indexes which process the document into one indexed value (or an array of values) whenever it changes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"compounds"),": multi-value indexes which let you query multiple field values at once. Advanced feature.")),(0,i.yg)("p",null,"See more on indexes ",(0,i.yg)("a",{parentName:"p",href:"/docs/local-storage/querying"},"here"),"."),(0,i.yg)("h2",{id:"types-of-fields"},"Types of fields"),(0,i.yg)("p",null,"Here's a list of field ",(0,i.yg)("inlineCode",{parentName:"p"},"type"),"s you can use in a collection, and their related options."),(0,i.yg)("h3",{id:"string"},(0,i.yg)("inlineCode",{parentName:"h3"},"'string'")),(0,i.yg)("p",null,"Defines a string field, as you'd expect."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.yg)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"default: string | (() => string)"),": define a default value, or a function that returns a default value at create time.")),(0,i.yg)("h3",{id:"number"},(0,i.yg)("inlineCode",{parentName:"h3"},"'number'")),(0,i.yg)("p",null,"Defines a number field, as you'd expect."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.yg)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"default: number | (() => number)"),": define a default value, or a function that returns a default value at create time.")),(0,i.yg)("h3",{id:"boolean"},(0,i.yg)("inlineCode",{parentName:"h3"},"'boolean'")),(0,i.yg)("p",null,"Defines a boolean field, as you'd expect."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.yg)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"default: boolean | (() => boolean)"),": define a default value, or a function that returns a default value at create time.")),(0,i.yg)("h3",{id:"array"},(0,i.yg)("inlineCode",{parentName:"h3"},"'array'")),(0,i.yg)("p",null,"Defines an array/list field. These can also act as sets. Arrays always default to empty."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"items: FieldSchema"),": a nested field schema definition which defines what each item in the array looks like."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.yg)("inlineCode",{parentName:"li"},"null")," as a valid value for this field.")),(0,i.yg)("h3",{id:"object"},(0,i.yg)("inlineCode",{parentName:"h3"},"'object'")),(0,i.yg)("p",null,"Defines an object/record field. Objects always default to empty. Objects have statically-defined keys, each of which can have its own unique sub-schema. For maps where keys aren't known until runtime, see ",(0,i.yg)("inlineCode",{parentName:"p"},"'map'"),"."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"properties: { [Key: string]: FieldSchema }"),": an object of key->value pairs, where values are nested field schema definitions which defines what kind of data exists on that key."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.yg)("inlineCode",{parentName:"li"},"null")," as a valid value for this field.")),(0,i.yg)("h3",{id:"map"},(0,i.yg)("inlineCode",{parentName:"h3"},"'map'")),(0,i.yg)("p",null,"Defines a key-value map field, where keys are arbitrary and added at runtime, and values are given a known schema. Maps are never nullable and default empty."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"values: FieldSchema"),": defines the sub-schema for values in the map.")),(0,i.yg)("h3",{id:"file"},(0,i.yg)("inlineCode",{parentName:"h3"},"'file'")),(0,i.yg)("p",null,"Defines a file field, which stores a file."),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.yg)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"downloadRemote: true"),": instructs the client to download and store file fields which are synced from other devices. By default, the client will instead load the file over the network. Using this is a tradeoff which enables offline file usage, but increases storage use.")),(0,i.yg)("h3",{id:"any"},(0,i.yg)("inlineCode",{parentName:"h3"},"'any'")),(0,i.yg)("p",null,"Opts out of schema checking for a field. An ",(0,i.yg)("inlineCode",{parentName:"p"},"any")," field can have nested data and can be used just like any other field, but no TypeScript types will be applied, and no runtime validation will occur (note: runtime validation doesn't currently exist, anyway...)"),(0,i.yg)("p",null,"Other options:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"default: any | (() => any)"),": define a default value for this field")),(0,i.yg)("h2",{id:"indexing-fields"},"Indexing Fields"),(0,i.yg)("p",null,"Indexes are vital to querying documents based on something other than primary key. If you're used to SQL or other systems with advanced query languages, it make take some effort to adjust to an index-centric system like Verdant."),(0,i.yg)("p",null,'Verdant\'s "after-the-fact" querying is actually quite constrained. It can only match against exact index values, or simple logic like "greater than" or "less than." You cannot, for example, query for posts whose title contains the word "local," ',(0,i.yg)("em",{parentName:"p"},"unless"),' you define an index which lets you do that "ahead-of-time" in your schema.'),(0,i.yg)("p",null,"This means it's easiest to keep your schema WIP until you've explored your application's logic domain enough to determine what kinds of queries you will need to make to provide functionality. You don't have to use the WIP feature, but each addition of a new index will require a schema revision if you don't. I find the easiest workflow is to start in WIP, build out functionality, determine what indexes to create, add them to the schema, and then finalize the schema."),(0,i.yg)("p",null,"For more information on how indexes work and how to define them, see ",(0,i.yg)("a",{parentName:"p",href:"/docs/local-storage/querying#indexes"},"the indexes section of query docs"),"."),(0,i.yg)("h2",{id:"recursive-fields"},"Recursive Fields"),(0,i.yg)("p",null,"It is currently possible to create recursive field schemas. Support is still experimental and the syntax for doing so is rather tedious, but once done, fields should be properly typed and validated."),(0,i.yg)("p",null,"To define recursive schema structures, you must first define a 'base' schema field assigned to a variable, then modify that field to assign its own reference to one of its nested structures. This two-step process is necessary because otherwise we'd encounter a \"used before it was defined\" type of error."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const contentBase = schema.fields.object({\n    // NOTE: it doesn't matter what you put here, as this will be replaced\n    // with the proceeding use of replaceObjectFields\n    fields: {},\n});\n\n// a manual typing of the field is required as Typescript cannot\n// infer recursive types. These \"Storage__FieldSchema\" types can all be\n// imported from '@verdant-web/store'.\ntype NestedContentFieldSchema = StorageObjectFieldSchema<{\n    type: StorageStringFieldSchema;\n    content: StorageArrayFieldSchema<NestedContentFieldSchema>;\n}>;\n\nconst nestedContent: NestedContentFieldSchema =\n    schema.fields.replaceObjectFields(contentBase, {\n        content: schema.fields.array({\n            // our recursive reference. use the original 'base' variable.\n            items: contentBase,\n        }),\n        // other fields should be added here as well.\n        type: schema.fields.string(),\n    });\n// you can now assign `nestedContent` to a collection field in your schema.\nconst post = schema.collection({\n    name: 'post',\n    primaryKey: 'id',\n    fields: {\n        id: schema.fields.id(),\n        body: nestedContent,\n    },\n});\n")),(0,i.yg)("p",null,"The call to ",(0,i.yg)("inlineCode",{parentName:"p"},"replaceObjectFields")," reassigns the ",(0,i.yg)("inlineCode",{parentName:"p"},"fields")," of the object field schema and updates the typing to reflect the recursion. The returned schema from this function has an ",(0,i.yg)("inlineCode",{parentName:"p"},"any")," applied type; you must manually typecast the returned variable using a custom defined field schema type as shown (Typescript cannot infer this for you)."),(0,i.yg)("p",null,"Once this is done, typings should still work when accessing recursive fields for index computation, and the CLI should generate appropriately defined named types for fields. For example, from the above code, a named alias type for ",(0,i.yg)("inlineCode",{parentName:"p"},"PostBodyContent")," would be created which would be defined as ",(0,i.yg)("inlineCode",{parentName:"p"},"PostBody[]"),"."),(0,i.yg)("h3",{id:"available-replace-field-helpers-for-recursion"},"Available ",(0,i.yg)("inlineCode",{parentName:"h3"},"replace")," field helpers for recursion"),(0,i.yg)("p",null,"Helpers are available not just for object fields, but all field types which nest and can therefore produce recursion:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"replaceObjectFields(objSchema, newFieldsSchema)")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"replaceArrayItems(arraySchema, newItemSchema)")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"replaceMapValues(mapSchema, newValueSchema)"))),(0,i.yg)("h3",{id:"limitations"},"Limitations"),(0,i.yg)("p",null,"You must not reuse a recursive field schema for multiple fields! When detecting cyclical references in the schema, only the first reference is captured as 'canonical,' so multiple reuses will all point to the first detected use. This will result in odd or incorrect generated typings from the CLI."),(0,i.yg)("p",null,"Instead, you must define each recursive field schema as a separate declaration. If you want identical field schemas for multiple fields, consider making a helper function which constructs your recursive field structure and then calling that multiple times to assign to new variables."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const postBody = makeNestedContentField();\nconst commentBody = makeNestedContentField();\n")),(0,i.yg)("h3",{id:"troubleshooting-recursive-fields"},"Troubleshooting recursive fields"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"When referencing a recursive field in ",(0,i.yg)("inlineCode",{parentName:"li"},"indexes")," in my schema, I get ",(0,i.yg)("inlineCode",{parentName:"li"},"Type instantiation is excessively deep and possibly infinite"),": You probably forgot to assign a manually crafted field schema type to the returned value of ",(0,i.yg)("inlineCode",{parentName:"li"},"replaceObjectFields"),"/",(0,i.yg)("inlineCode",{parentName:"li"},"replaceArrayItems"),"/",(0,i.yg)("inlineCode",{parentName:"li"},"replaceMapValues"),".")))}p.isMDXComponent=!0}}]);