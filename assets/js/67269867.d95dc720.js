"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2312],{6608:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"sync/storage","title":"Server Persistent Storage","description":"Verdant only supports SQLite-backed server storage at the moment. Each Verdant library is stored as a separate SQLite database.","source":"@site/docs/sync/storage.md","sourceDirName":"sync","slug":"/sync/storage","permalink":"/docs/sync/storage","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Pruning Invalid Data","permalink":"/docs/sync/pruning"},"next":{"title":"Access Control","permalink":"/docs/sync/access"}}');var s=r(1273),n=r(8576);const o={sidebar_position:9},i="Server Persistent Storage",d={},c=[{value:"Database-per-library tradeoff",id:"database-per-library-tradeoff",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"server-persistent-storage",children:"Server Persistent Storage"})}),"\n",(0,s.jsx)(t.p,{children:"Verdant only supports SQLite-backed server storage at the moment. Each Verdant library is stored as a separate SQLite database."}),"\n",(0,s.jsxs)(t.p,{children:["You import the type of storage you want from ",(0,s.jsx)(t.code,{children:"@verdant-web/server/storage"})," and pass it to the ",(0,s.jsx)(t.code,{children:"storage"})," parameter of the ",(0,s.jsx)(t.code,{children:"Server"})," constructor options."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"import { Server } from '@verdant-web/server';\nimport { sqlStorage, sqlShardStorage } from '@verdant-web/server/storage';\n\nconst serverUnified = new Server({\n\t// ...\n\tstorage: sqlStorage({ databaseFile: 'verdant.sqlite' }),\n});\n\nconst serverSharded = new Server({\n\t// ...\n\tstorage: sqlShardStorage({\n\t\tdatabasesDirectory: 'verdant-databases',\n\t\t// you can transfer from a previous unified database...\n\t\ttransferFromUnifiedDatabaseFile: 'verdant.sqlite',\n\t}),\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In addition, storage supports the ",(0,s.jsx)(t.code,{children:"disableWal"})," option, which switches off the WAL in SQLite. I don't think you'd want to do that, but, it's there. Remember Verdant makes frequent writes during high traffic periods."]}),"\n",(0,s.jsx)(t.h2,{id:"database-per-library-tradeoff",children:"Database-per-library tradeoff"}),"\n",(0,s.jsx)(t.p,{children:"There are drawbacks to database-per-tenant models, but most of them don't apply to Verdant:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Migration of database schema requires more coordination: Verdant will handle these for you and they are not likely to happen very often, if at all."}),"\n",(0,s.jsx)(t.li,{children:"Having to coordinate which database to query: again, Verdant handles this just fine for you."}),"\n",(0,s.jsx)(t.li,{children:"Hard to aggregate query across multiple databases: there's no reason to do this with the kind of data Verdant stores."}),"\n",(0,s.jsx)(t.li,{children:"Backups require copying all files: this one's kinda applicable, but backups are also a lot less critical in local-first, since the server can restore from client replicas."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8576:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>i});var a=r(3917);const s={},n=a.createContext(s);function o(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);