"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8005],{3749:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"local-storage/undo","title":"Undo, Redo, and Batching","description":"Local changes are undoable as long as you don\'t refresh the page. To undo a change, call client.undoHistory.undo(). To redo and undone change, call client.undoHistory.redo().","source":"@site/docs/local-storage/undo.md","sourceDirName":"local-storage","slug":"/local-storage/undo","permalink":"/docs/local-storage/undo","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Documents & Entities","permalink":"/docs/local-storage/entities"},"next":{"title":"File storage","permalink":"/docs/local-storage/files"}}');var a=n(1273),i=n(8576);const s={sidebar_position:6},r="Undo, Redo, and Batching",c={},d=[{value:"Undo behavior",id:"undo-behavior",level:2},{value:"Batching for more control",id:"batching-for-more-control",level:2},{value:"Using the batch object",id:"using-the-batch-object",level:3},{value:"Batch default timeout",id:"batch-default-timeout",level:3},{value:"Configuring timeout or max item count",id:"configuring-timeout-or-max-item-count",level:3}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"undo-redo-and-batching",children:"Undo, Redo, and Batching"})}),"\n",(0,a.jsxs)(t.p,{children:["Local changes are undoable as long as you don't refresh the page. To undo a change, call ",(0,a.jsx)(t.code,{children:"client.undoHistory.undo()"}),". To redo and undone change, call ",(0,a.jsx)(t.code,{children:"client.undoHistory.redo()"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["You can also manually add events to the undo history. Call ",(0,a.jsx)(t.code,{children:"client.undoHistory.addUndo(() => { /* your code */ })"})," to add an event to the undo stack. If your callback returns another callback, it will be added to the redo stack automatically. If you do this, your redo can also return a callback to undo, etc, ad infinitum. It's recommended if you want redoable changes."]}),"\n",(0,a.jsxs)(t.p,{children:["Alternatively, you can use ",(0,a.jsx)(t.code,{children:"client.undoHistory.addRedo"})," to manually push a redo operation. You could achieve undo/redo just by using these, like calling ",(0,a.jsx)(t.code,{children:"addRedo"})," right after you call ",(0,a.jsx)(t.code,{children:"undo"})," every time to queue the redo operation yourself."]}),"\n",(0,a.jsx)(t.h2,{id:"undo-behavior",children:"Undo behavior"}),"\n",(0,a.jsxs)(t.p,{children:["As soon as you call ",(0,a.jsx)(t.code,{children:"addUndo"}),", or whenever the user modifies data in an undoable way, the redo stack is dropped. This is meant to be consistent with normal OS undo/redo behavior - after undoing a few operations, if you do something new, you can no longer redo those original operations; you've entered a new timeline, as it were."]}),"\n",(0,a.jsx)(t.h2,{id:"batching-for-more-control",children:"Batching for more control"}),"\n",(0,a.jsx)(t.p,{children:"You can batch changes together to craft more intentional undo steps, or even turn off undo for particular changes."}),"\n",(0,a.jsxs)(t.p,{children:["Call ",(0,a.jsx)(t.code,{children:"client.batch()"})," to receive a batch object. You can pass a configuration to modify batch behavior. The most important configuration parameter is ",(0,a.jsx)(t.code,{children:"undoable: false"}),", which will make all changes in the batch non-undoable. ",(0,a.jsx)(t.strong,{children:"*This doesn't mean that they are permanent"}),"; it means that when the user performs an undo, it will skip over anything in the batch and undo the previous operations in history instead."]}),"\n",(0,a.jsx)(t.h3,{id:"using-the-batch-object",children:"Using the batch object"}),"\n",(0,a.jsx)(t.p,{children:"The returned batch object object has three methods."}),"\n",(0,a.jsxs)(t.p,{children:["The first is ",(0,a.jsx)(t.code,{children:".run(() => { ... })"})," which accepts a synchronous function, in which you apply any changes you like to entities. It returns the batch (chaining API) so you can call other methods."]}),"\n",(0,a.jsxs)(t.p,{children:["The second is ",(0,a.jsx)(t.code,{children:".flush()"})," which pushes your changes onto the undo stack (unless you opted out) and also submits them to sync."]}),"\n",(0,a.jsxs)(t.p,{children:["The third is ",(0,a.jsx)(t.code,{children:".discard()"}),", which can be used to drop any unflushed changes and remove the batch from memory."]}),"\n",(0,a.jsx)(t.p,{children:"For example, you might do something like this to avoid undo:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const item = await client.items.get('some-id').resolved;\n\nclient\n\t.batch({ undoable: false })\n\t.run(() => {\n\t\titem.set('content', 'hello world');\n\t\titem.set('category', 'none');\n\t})\n\t.flush();\n"})}),"\n",(0,a.jsx)(t.h3,{id:"batch-default-timeout",children:"Batch default timeout"}),"\n",(0,a.jsx)(t.p,{children:"All batches (including the default ambient one) timeout after 200 milliseconds by default. This was meant to stay out of your way for longer-running batched operations but still ensure your changes get submitted. This behavior is a little naive and may change in the future."}),"\n",(0,a.jsx)(t.h3,{id:"configuring-timeout-or-max-item-count",children:"Configuring timeout or max item count"}),"\n",(0,a.jsxs)(t.p,{children:["You can configure your own timeout value or maximum number of operations to buffer in your batch by passing ",(0,a.jsx)(t.code,{children:"max"})," or ",(0,a.jsx)(t.code,{children:"timeout"})," to the ",(0,a.jsx)(t.code,{children:"client.batch({})"})," configuration. You can continue to reuse the same batch even if you hit these limits; your first operations will be flushed automatically, and new ones will be flushed after the ",(0,a.jsx)(t.code,{children:"timeout"})," has expired or whenever enough changes are accumulated to reach ",(0,a.jsx)(t.code,{children:"max"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If you want to disable the timeout and maximum and rely only on manually invoking ",(0,a.jsx)(t.code,{children:".flush()"}),", you can pass ",(0,a.jsx)(t.code,{children:"null"})," to both values. Be sure to call ",(0,a.jsx)(t.code,{children:".flush()"})," though - there are no other safeguards. Your changes will exist in memory immediately, but will not be stored or synced if you fail to call ",(0,a.jsx)(t.code,{children:".flush"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Using the advanced configuration, you could batch together multiple operations so that they are all undone in one step, guaranteed:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const batch = client.batch({ timeout: null, max: null });\ntry {\n\tbatch.run(() => {\n\t\titem.set('content', 'test');\n\t});\n\tconst result = await fetch('/some-data');\n\tconst body = await result.json();\n\tbatch.run(() => {\n\t\titem.set('data', body.data);\n\t});\n\tawait batch.flush();\n} catch (err) {\n\tconsole.log('Failed to get metadata!');\n\tbatch.discard();\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now if the user uses undo, both the ",(0,a.jsx)(t.code,{children:"content"})," and ",(0,a.jsx)(t.code,{children:"data"})," fields will be unwritten - even though there was a full request cycle between setting them."]}),"\n",(0,a.jsx)(t.p,{children:"You should note, however, that these changes will also delay syncing until the batch completes, which may be less responsive for multiplayer."}),"\n",(0,a.jsxs)(t.p,{children:["Also note the ",(0,a.jsx)(t.code,{children:"try/catch"})," and use of discard here. In this case, we have written the logic so that if the request fails, the entire attempt to update the item is abandoned. If we had not caught an error, we might never call ",(0,a.jsx)(t.code,{children:".flush"}),", and the batch would remain in-memory and idle, which is not the end of the world, but is also pretty gross."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8576:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(3917);const a={},i=o.createContext(a);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);