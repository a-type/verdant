"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2312],{715:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"sync/storage","title":"Server Persistent Storage","description":"Verdant only supports SQLite-backed server storage at the moment, but in two flavors:","source":"@site/docs/sync/storage.md","sourceDirName":"sync","slug":"/sync/storage","permalink":"/docs/sync/storage","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Pruning Invalid Data","permalink":"/docs/sync/pruning"},"next":{"title":"Access Control","permalink":"/docs/sync/access"}}');var n=r(7557),s=r(6039);const o={sidebar_position:9},i="Server Persistent Storage",d={},l=[{value:"Tradeoffs",id:"tradeoffs",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"server-persistent-storage",children:"Server Persistent Storage"})}),"\n",(0,n.jsx)(t.p,{children:"Verdant only supports SQLite-backed server storage at the moment, but in two flavors:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Unified: writes to a single database file. Stable and well-tested, but doesn't scale to many libraries at once."}),"\n",(0,n.jsx)(t.li,{children:"Sharded: writes one database file per library. Still experimental and being vetted as of writing. Should scale better to large apps."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["You import the type of storage you want from ",(0,n.jsx)(t.code,{children:"@verdant-web/server/storage"})," and pass it to the ",(0,n.jsx)(t.code,{children:"storage"})," parameter of the ",(0,n.jsx)(t.code,{children:"Server"})," constructor options."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"import { Server } from '@verdant-web/server';\nimport { sqlStorage, sqlShardStorage } from '@verdant-web/server/storage';\n\nconst serverUnified = new Server({\n\t// ...\n\tstorage: sqlStorage({ databaseFile: 'verdant.sqlite' }),\n});\n\nconst serverSharded = new Server({\n\t// ...\n\tstorage: sqlShardStorage({\n\t\tdatabasesDirectory: 'verdant-databases',\n\t\t// you can transfer from a previous unified database...\n\t\ttransferFromUnifiedDatabaseFile: 'verdant.sqlite',\n\t}),\n});\n"})}),"\n",(0,n.jsx)(t.p,{children:"Sharded storage supports automatic transfer from a prior unified database on startup, but it's not guaranteed to be fast. It should only happen once, though."}),"\n",(0,n.jsxs)(t.p,{children:["In addition, both storage types support the ",(0,n.jsx)(t.code,{children:"disableWal"})," option, which switches off the WAL in SQLite. I don't think you'd want to do that, but, it's there. Remember Verdant makes frequent writes during high traffic periods."]}),"\n",(0,n.jsx)(t.h2,{id:"tradeoffs",children:"Tradeoffs"}),"\n",(0,n.jsx)(t.p,{children:"Most likely, once sharded storage is proven stable, you'll want to use that."}),"\n",(0,n.jsx)(t.p,{children:"There are drawbacks to database-per-tenant models, but most of them don't apply to Verdant:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Migration of database schema requires more coordination: Verdant will handle these for you and they are not likely to happen very often, if at all."}),"\n",(0,n.jsx)(t.li,{children:"Having to coordinate which database to query: again, Verdant handles this just fine for you."}),"\n",(0,n.jsx)(t.li,{children:"Hard to aggregate query across multiple databases: there's no reason to do this with the kind of data Verdant stores."}),"\n",(0,n.jsx)(t.li,{children:"Backups require copying all files: this one's kinda applicable, but backups are also a lot less critical in local-first, since the server can restore from client replicas."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"There's one more tradeoff, which is cold start time for initial sync on a library. When a new replica for a library sends a message to the server, it will open the sharded database for that library if it's not already loaded. This can take up to a couple hundred milliseconds in my testing. I do not believe it should take longer for larger databases, but I'm still getting an idea of it."}),"\n",(0,n.jsx)(t.p,{children:"Either way, database connections are kept alive for a while after cold start (default: 1 hour). So this is a one-time initial sync cost."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},6039:(e,t,r)=>{r.d(t,{R:()=>o,x:()=>i});var a=r(8225);const n={},s=a.createContext(n);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);