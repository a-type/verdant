"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8376],{1809:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"integrations/tiptap","title":"TipTap Text Editor","description":"An experimental integration is available for integrating Verdant with the TipTap rich text editor. Currently this integration provides a premade Verdant field schema for a TipTap document which enforces correct (but generic) shape, and a React hook to instantiate a Verdant-synced TipTap Editor instance with one line.","source":"@site/docs/integrations/tiptap.md","sourceDirName":"integrations","slug":"/integrations/tiptap","permalink":"/docs/integrations/tiptap","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"sidebar_position":0},"sidebar":"tutorialSidebar","previous":{"title":"Integrations","permalink":"/docs/category/integrations"},"next":{"title":"How it works","permalink":"/docs/category/how-it-works"}}');var o=n(7557),a=n(6039);const s={sidebar_position:0},r="TipTap Text Editor",d={},l=[{value:"Creating a TipTap document schema field",id:"creating-a-tiptap-document-schema-field",level:2},{value:"Using the TipTap Extension",id:"using-the-tiptap-extension",level:2},{value:"Why <code>parent</code> and <code>fieldName</code>?",id:"why-parent-and-fieldname",level:3},{value:"A note on Undo/Redo",id:"a-note-on-undoredo",level:2},{value:"Using Verdant&#39;s Undo/Redo",id:"using-verdants-undoredo",level:3},{value:"Using TipTap&#39;s Undo/Redo",id:"using-tiptaps-undoredo",level:3},{value:"Inserting files and media",id:"inserting-files-and-media",level:2},{value:"Customizing the Verdant media extension",id:"customizing-the-verdant-media-extension",level:3},{value:"Usage with React",id:"usage-with-react",level:2},{value:"Document node identities",id:"document-node-identities",level:2},{value:"A note on &quot;collaborative text&quot;",id:"a-note-on-collaborative-text",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"tiptap-text-editor",children:"TipTap Text Editor"})}),"\n",(0,o.jsxs)(t.p,{children:["An experimental integration is available for integrating Verdant with the ",(0,o.jsx)(t.a,{href:"https://tiptap.dev",children:"TipTap rich text editor"}),". Currently this integration provides a premade Verdant field schema for a TipTap document which enforces correct (but generic) shape, and a React hook to instantiate a Verdant-synced TipTap Editor instance with one line."]}),"\n",(0,o.jsxs)(t.p,{children:["Verdant ",(0,o.jsx)(t.strong,{children:"does not currently support simultaneous text editing"}),", so don't expect a magical experience here. Use of Verdant with TipTap is mostly recommended for single-user use cases. Otherwise, you will probably want to use ",(0,o.jsx)(t.a,{href:"/docs/sync/presence",children:"presence"})," to lock text blocks while another user is editing them to avoid conflicts. Collaboration should work fairly well as long as users don't try to modify the same string at the same time."]}),"\n",(0,o.jsx)(t.h2,{id:"creating-a-tiptap-document-schema-field",children:"Creating a TipTap document schema field"}),"\n",(0,o.jsxs)(t.p,{children:["You can construct a schema for a field which represents a text document by importing ",(0,o.jsx)(t.code,{children:"createTipTapFieldSchema"})," and passing the result to your schema field."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"import { schema } from '@verdant-web/store';\nimport { createTipTapFieldSchema } from '@verdant-web/tiptap';\n\nexport default schema({\n\tversion: 1,\n\tcollections: {\n\t\tposts: schema.collection({\n\t\t\tname: 'post',\n\t\t\tprimaryKey: 'id',\n\t\t\tfields: {\n\t\t\t\tid: schema.fields.id(),\n\t\t\t\tbody: createTipTapFieldSchema({\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\ttype: 'doc',\n\t\t\t\t\t\tcontent: [],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t},\n\t\t}),\n\t},\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["You are required to specify a default document value. This can be ",(0,o.jsx)(t.code,{children:"null"}),", which will make your field nullable. If it's not null, it must at least have ",(0,o.jsx)(t.code,{children:"type"})," (the type of the root document node). You can also specify ",(0,o.jsx)(t.code,{children:"content"})," (an array of child nodes), ",(0,o.jsx)(t.code,{children:"attrs"})," (a record, where values can be anything), and ",(0,o.jsx)(t.code,{children:"text"})," (if your root node is a text node -- unlikely). The above example is recommended."]}),"\n",(0,o.jsxs)(t.p,{children:["If you pass ",(0,o.jsx)(t.code,{children:"null"}),", your field will begin as ",(0,o.jsx)(t.code,{children:"null"})," unless otherwise specified. If the user adds a document to the field, you are responsible for ensuring the initial state of that document. See ",(0,o.jsx)(t.code,{children:"nullDocumentDefault"})," in ",(0,o.jsx)(t.code,{children:"useSyncedEditor"})," below."]}),"\n",(0,o.jsx)(t.h2,{id:"using-the-tiptap-extension",children:"Using the TipTap Extension"}),"\n",(0,o.jsx)(t.p,{children:"Verdant ships a TipTap extension which handles syncing your document to a document field on an entity. You must import the extension from the library and configure it with your field data."}),"\n",(0,o.jsxs)(t.p,{children:["For additional type safety, there's also a helper function exported called ",(0,o.jsx)(t.code,{children:"createVerdantExtension"}),", which enforces that the field you select is actually part of the schema of the entity you provide. I recommend using this so that changes in your document structure don't silently break your TipTap editor."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:"import { createVerdantExtension } from '@verdant-web/tiptap';\nimport { Editor } from '@tiptap/core';\n\n// suppose we have a Verdant entity which has a tiptap field\n// assigned to the 'document' field name in the schema...\nconst parentEntity = await client.posts.get('some-post-id');\n\nconst editor = new Editor({\n\t// ... other options ...\n\textensions: [\n\t\tcreateVerdantExtension(\n\t\t\t// first, we pass the parent entity\n\t\t\tparentEntity,\n\t\t\t// then, the field name where the tiptap document is located\n\t\t\t'document',\n\t\t\t{\n\t\t\t\t// optional additional configuration\n\t\t\t\tnullDocumentDefault: ...,\n\t\t\t\tbatchConfig: {\n\t\t\t\t\tbatchName: 'tiptap',\n\t\t\t\t\tmax: 100,\n\t\t\t\t\ttimeout: 1000,\n\t\t\t\t\tundoable: false,\n\t\t\t\t}\n\t\t\t},\n\t\t),\n\t],\n});\n"})}),"\n",(0,o.jsx)(t.p,{children:"When the extension is added, it will take care of diffing and synchronizing the TipTap editor data to your Verdant storage. It doesn't do presence or cursors (yet?)."}),"\n",(0,o.jsxs)(t.p,{children:["Under the hood, this extension is also doing its best to track the identities of the nodes in your document, so that the diffing algorithm can preserve node identity during changes wherever possible. Due to limitations in the TipTap/Prosemirror model around inline nodes, however, this only works with block-level nodes like paragraphs. Any changes to the actual text in a ",(0,o.jsx)(t.code,{children:"text"})," node will fully overwrite the previous contents of that node when merged, using last-write-wins."]}),"\n",(0,o.jsx)(t.p,{children:"I hope to improve the diffing of the extension over time."}),"\n",(0,o.jsxs)(t.h3,{id:"why-parent-and-fieldname",children:["Why ",(0,o.jsx)(t.code,{children:"parent"})," and ",(0,o.jsx)(t.code,{children:"fieldName"}),"?"]}),"\n",(0,o.jsxs)(t.p,{children:["It may seem a little strange or awkward to require passing the parent of the actual TipTap field instead of just the field directly. While the API is a little odd, it's designed for resiliency. By having a reference to the parent, the extension is able to fully initialize and assign a brand new document while seamlessly tracking changes as needed. This is mostly relevant if your document field is nullable: if the value is ",(0,o.jsx)(t.code,{children:"null"}),", a new document will be initialized for you when the user begins typing in the editor."]}),"\n",(0,o.jsxs)(t.p,{children:["To that end, if your field ",(0,o.jsx)(t.em,{children:"is"})," nullable with no default document shape, you ",(0,o.jsx)(t.strong,{children:"must"})," pass the ",(0,o.jsx)(t.code,{children:"nullDocumentDefault"})," to the extension options. The extension will enforce this at runtime. This gives it the appropriate document shape when filling in the missing field value."]}),"\n",(0,o.jsx)(t.h2,{id:"a-note-on-undoredo",children:"A note on Undo/Redo"}),"\n",(0,o.jsxs)(t.p,{children:["TipTap's ",(0,o.jsx)(t.a,{href:"https://tiptap.dev/docs/editor/extensions/functionality/starterkit",children:"Starter Kit"})," extension includes the ",(0,o.jsx)(t.a,{href:"https://tiptap.dev/docs/editor/extensions/functionality/undo-redo",children:"Undo/Redo"})," extension by default. ",(0,o.jsx)(t.strong,{children:"This will conflict with Verdant's built-in Undo/Redo behavior"}),". You should choose one, but they both work!"]}),"\n",(0,o.jsx)(t.h3,{id:"using-verdants-undoredo",children:"Using Verdant's Undo/Redo"}),"\n",(0,o.jsx)(t.p,{children:"Using Verdant for undo history is recommended if you want to seamlessly integrate undo history with other changes outside your TipTap editor, like if your user is going back and forth between the editor and other parts of the app, or if a feature in your editor modifies data outside the document (like a button which modifies some other part of an entity)."}),"\n",(0,o.jsx)(t.p,{children:"To use Verdant's undo history, make sure you turn off TipTap's history if you are using the Starter Kit:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"const editor = new Editor({\n\t// ... other options ...\n\textensions: [\n\t\tStarterKit.configure({\n\t\t\t// Turn off TipTap's undo history.\n\t\t\thistory: false,\n\t\t}),\n\t\tcreateVerdantExtension(parentEntity, 'document'),\n\t],\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["You can also configure how Verdant batches your edits into undo items via extension options using the ",(0,o.jsx)(t.code,{children:"batchConfig"})," key. These use the same options as ",(0,o.jsx)(t.code,{children:"client.batch"}),". See ",(0,o.jsx)(t.a,{href:"/docs/local-storage/undo#configuring-timeout-or-max-item-count",children:"batching docs"}),'. However, this does not expose any way to do semantic batching; Verdant doesn\'t understand "rich text document" and may arbitrarily batch portions of a paragraph in separate commits.']}),"\n",(0,o.jsx)(t.h3,{id:"using-tiptaps-undoredo",children:"Using TipTap's Undo/Redo"}),"\n",(0,o.jsx)(t.p,{children:"You can instead turn off Verdant's undo tracking and rely on TipTap's undo behavior. This might be better if your experience is solely focused on text editing. Changes produced by TipTap's built-in undo will be consumed as normal diff changes to the Verdant data as they are emitted."}),"\n",(0,o.jsx)(t.p,{children:"You may see improvements to the semantic undo behavior with this approach as TipTap is more likely to have tuned their undo partitioning to match user expectations when typing, but there's not really any guarantee that's true, and I haven't bothered to read their source code for their Undo extension."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"const editor = new Editor({\n\t// ... other options ...\n\textensions: [\n\t\tStarterKit, // or History if you don't want all of StarterKit\n\t\tcreateVerdantExtension(parentEntity, 'document', {\n\t\t\tbatchConfig: {\n\t\t\t\t// Turn off Verdant undo tracking for this editor\n\t\t\t\tundoable: false,\n\t\t\t},\n\t\t}),\n\t],\n});\n"})}),"\n",(0,o.jsx)(t.h2,{id:"inserting-files-and-media",children:"Inserting files and media"}),"\n",(0,o.jsx)(t.p,{children:"Verdant's TipTap integration has experimental support for seamless file paste, drop, or manual insertion via an editor command. It's experimental because the usage is a bit awkward and may change at some point."}),"\n",(0,o.jsx)(t.p,{children:"Supporting file uploads requires another Verdant field, a map of files which keeps track of the files uploaded and 'attached' to TipTap nodes. It is only recommended to put this field on the same Verdant document as your TipTap document field. For example:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"import { schema } from '@verdant-web/store';\nimport {\n\tcreateTipTapFieldSchema,\n\tcreateTipTapFileMapSchema,\n} from '@verdant-web/tiptap';\n\nexport default schema({\n\tversion: 1,\n\tcollections: {\n\t\tposts: schema.collection({\n\t\t\tname: 'post',\n\t\t\tprimaryKey: 'id',\n\t\t\tfields: {\n\t\t\t\tid: schema.fields.id(),\n\t\t\t\tbody: createTipTapFieldSchema({\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\ttype: 'doc',\n\t\t\t\t\t\tcontent: [],\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t\t// add your file map\n\t\t\t\tfiles: createTipTapFileMapSchema(),\n\t\t\t},\n\t\t}),\n\t},\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Once you have this field, you can configure the ",(0,o.jsx)(t.code,{children:"VerdantMediaExtension"})," with it. This extension will handle paste and file drop events, and provides a custom node to display the files in a minimal way. You probably want to extend this node with NodeView of your own. For similarity to the main Verdant extension, a ",(0,o.jsx)(t.code,{children:"createVerdantMediaExtension"})," function is provided, but there's not really any difference from ",(0,o.jsx)(t.code,{children:"VerdantMediaExtension.configure"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"new Editor({\n\textensions: [\n\t\tcreateVerdantExtension(post, 'body'),\n\t\tcreateVerdantMediaExtension(post.get('files')),\n\t],\n});\n"})}),"\n",(0,o.jsx)(t.p,{children:"With this extension added, paste and drop should insert new file nodes which display any image, video, or audio in the editor. Other file types will render as a download link."}),"\n",(0,o.jsx)(t.h3,{id:"customizing-the-verdant-media-extension",children:"Customizing the Verdant media extension"}),"\n",(0,o.jsx)(t.p,{children:"The default media extension behavior is probably too ugly for your purposes. You can write your own custom NodeView to render the files in a different way, if you want. But there are some important things you need to know:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["The file is not actually stored on the Node, only a reference to the key in the file map field. Your node view must retrieve the file from ",(0,o.jsx)(t.code,{children:"extension.options.fileMap"}),", which is the same map field you passed into the extension originally."]}),"\n",(0,o.jsxs)(t.li,{children:["Files in Verdant are not preloaded before being available, so files may start in a loading state. To accommodate this, you must subscribe to the ",(0,o.jsx)(t.code,{children:"change"})," event on the file and update your node view. When a file is loading, ",(0,o.jsx)(t.code,{children:"file.loading"})," will be true and ",(0,o.jsx)(t.code,{children:"file.url"})," will be null. If loading fails for any reason, ",(0,o.jsx)(t.code,{children:"file.failed"})," will be true. Otherwise, ",(0,o.jsx)(t.code,{children:"file.url"})," should be defined and ready for use."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"See the source of the VerdantMediaExtension for an example plain JS node view which accounts for these things, with comments documenting the behavior."}),"\n",(0,o.jsxs)(t.p,{children:["Due to the dynamic nature of file loading, it's probably easier to use React for your node view if your project is already React. You can also use Verdant hooks in your React node view, like ",(0,o.jsx)(t.code,{children:"useWatch(file)"}),", to take care of the plumbing aspects."]}),"\n",(0,o.jsx)(t.h2,{id:"usage-with-react",children:"Usage with React"}),"\n",(0,o.jsx)(t.p,{children:"The library provides a single hook you can use to create a TipTap Editor that's backed with Verdant. It really just wraps the creation and configuration of the extension as shown above."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-tsx",children:"import { useSyncedEditor } from '@verdant-web/tiptap/react';\nimport { EditorContent } from '@tiptap/react';\nimport StarterKit from '@tiptap/starter-kit';\n\nfunction DocumentEditor({ post }: { post: Post }) {\n\tconst { files } = hooks.useWatch(post);\n\tconst editor = useSyncedEditor(post, 'body', {\n\t\t// optional:\n\t\tfiles,\n\t\teditorOptions: {\n\t\t\textensions: [StarterKit],\n\t\t},\n\t});\n\n\treturn (\n\t\t<EditorContent\n\t\t\teditor={editor}\n\t\t\tstyle={{ width: 500, height: 300, border: '1px solid black' }}\n\t\t/>\n\t);\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"The parameters of the hook are:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"The parent object or document which has the TipTap field. You must pass the parent, not the field itself. This is to support cases where we must reassign the parent field entirely, like initializing a fresh document."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"The name of the field which has the TipTap document. This will be typechecked against the first parameter."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Additional options, including:"}),"\n",(0,o.jsxs)(t.p,{children:["a. ",(0,o.jsx)(t.code,{children:"files"}),": A reference to a file map field. Passing this automatically configures and adds the ",(0,o.jsx)(t.code,{children:"VerdantMediaExtension"}),".\nb. ",(0,o.jsx)(t.code,{children:"nullDocumentDefault"}),": A default document snapshot value to use if the document field is ",(0,o.jsx)(t.code,{children:"null"}),". You should provide this if your field is nullable and you haven't included any logic to prevent the rendering of the current component if the field is missing. It must be a full document snapshot and will be passed to the editor until the Verdant field is initialized on first change."]}),"\n",(0,o.jsxs)(t.p,{children:["c. ",(0,o.jsx)(t.code,{children:"editorOptions"}),": Additional options to configure the editor, see ",(0,o.jsx)(t.code,{children:"useEditor"})," from TipTap's React library"]}),"\n",(0,o.jsxs)(t.p,{children:["d. ",(0,o.jsx)(t.code,{children:"editorDependencies"}),": Values to include in the dependency array of ",(0,o.jsx)(t.code,{children:"useEditor"}),". Be careful, these will cause the editor to be recreated when changing.\ne. ",(0,o.jsx)(t.code,{children:"extensionOptions"}),": Any other options you want to use to configure the Verdant TipTap extension, see docs in previous section."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Other than that, everything is taken care of. Pass the ",(0,o.jsx)(t.code,{children:"editor"})," returned to the ",(0,o.jsx)(t.code,{children:"editor"})," prop of ",(0,o.jsx)(t.code,{children:"EditorContent"})," from ",(0,o.jsx)(t.code,{children:"@tiptap/react"}),", and you can now edit the document and watch as changes are persisted locally and synced to peers."]}),"\n",(0,o.jsx)(t.h2,{id:"document-node-identities",children:"Document node identities"}),"\n",(0,o.jsxs)(t.p,{children:["First, I recommend you consider supporting TipTap by licensing their ",(0,o.jsx)(t.a,{href:"https://tiptap.dev/docs/editor/extensions/functionality/uniqueid",children:"official UniqueID extension"})," to assign and track IDs on nodes. But, that said..."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"@verdant-web/tiptap"}),' extension already has to track node identities to apply proper diffing rules, and it does so by assigning the Verdant system\'s internal "object identifier" value to the ',(0,o.jsx)(t.code,{children:"attrs"})," of each non-inline node. It is possible to reference this attribute, just import the key from ",(0,o.jsx)(t.code,{children:"verdantIdAttribute"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["To actually support inline presence decorations, though, you will have to use a custom node view to apply the presence UI on each block. I leave that up to you and the ",(0,o.jsx)(t.a,{href:"https://tiptap.dev/docs/editor/extensions/custom-extensions/node-views",children:"TipTap docs"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"a-note-on-collaborative-text",children:'A note on "collaborative text"'}),"\n",(0,o.jsxs)(t.p,{children:["As stated in the introduction, Verdant doesn't currently support realtime collaborative ",(0,o.jsx)(t.em,{children:"text editing"}),", like you might expect from, say, Google Docs. This doesn't mean users can't collaborate on a document at all. What it means, specifically, is that two users editing the same exact paragraph (or any text node) will have a bad time, with each person's changes disrupting the other, and cursor position may jump around unexpectedly, etc."]}),"\n",(0,o.jsx)(t.p,{children:"I don't have any particular plans to support collaborative string editing. So keep that in mind. The existence of this integration doesn't imply any further development or support on that front."}),"\n",(0,o.jsxs)(t.p,{children:["That said, there are simple UX tricks you can use to avoid simultaneous edits of the same text node. I think locking a node while another user is editing it using ",(0,o.jsx)(t.a,{href:"/docs/sync/presence",children:"presence"})," isn't terrible, personally. I like to imagine what would happen if you were actually collaborating with someone on a document in real life -- probably only one person would be actively writing at any point in time. I think it's more compelling to imagine digital analogues to that human experience than to enable very complicated simultaneous edit behavior which has no physical basis. But that's my own biases showing."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},6039:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(8225);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);