"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9241],{7624:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"react/reactivity","title":"Reactivity","description":"Once you have loaded documents via queries, you will definitely want to write React components in such a way that they are properly re-rendered when data changes.","source":"@site/docs/react/reactivity.md","sourceDirName":"react","slug":"/react/reactivity","permalink":"/docs/react/reactivity","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Query hooks","permalink":"/docs/react/queries"},"next":{"title":"\'Field\' ergonomics","permalink":"/docs/react/field"}}');var a=n(7557),o=n(6039);const i={sidebar_position:3},r="Reactivity",l={},c=[{value:"Tip: Fine-grained watching",id:"tip-fine-grained-watching",level:3},{value:"Tip: Use the named generated types",id:"tip-use-the-named-generated-types",level:3},{value:"Deep watching",id:"deep-watching",level:2},{value:"Watching files",id:"watching-files",level:2},{value:"Handling nullability",id:"handling-nullability",level:2},{value:"Null handling by example",id:"null-handling-by-example",level:2},{value:"Null handling works for root documents, too",id:"null-handling-works-for-root-documents-too",level:2},{value:"Bypassing the React lifecycle",id:"bypassing-the-react-lifecycle",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"reactivity",children:"Reactivity"})}),"\n",(0,a.jsxs)(t.p,{children:["Once you have loaded documents via ",(0,a.jsx)(t.a,{href:"/docs/react/queries",children:"queries"}),", you will definitely want to write React components in such a way that they are properly re-rendered when data changes."]}),"\n",(0,a.jsx)(t.p,{children:'The nature of local-first data is reactive, since the system is designed inherently to support realtime collaboration. While you can read data from documents (also called "entities" throughout these docs) without subscribing to changes, this is not recommended!'}),"\n",(0,a.jsxs)(t.p,{children:["Reactivity in Verdant revolves around one hook: ",(0,a.jsx)(t.code,{children:"useWatch"}),". Requiring the use of a hook to respond to data changes may seem cumbersome for developers coming from another framework or a more 'magic' system like MobX, but I like to think Verdant's approach strikes a good balance between explicitness and terseness."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"useWatch"}),", by default, is ",(0,a.jsx)(t.strong,{children:"field-level granular"})," reactivity. This means when you pass an entity to ",(0,a.jsx)(t.code,{children:"useWatch"}),", it only watches ",(0,a.jsx)(t.em,{children:"the direct child fields of that entity"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const { name, avatar, tags } = hooks.useWatch(person);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In the above example, if ",(0,a.jsx)(t.code,{children:"tags"})," is a list of string tags, the component calling this hook ",(0,a.jsx)(t.strong,{children:"will not"})," re-render if tags are added or removed. However, it will re-render if ",(0,a.jsx)(t.code,{children:"name"})," is changed, if the avatar file is replaced, or if the ",(0,a.jsx)(t.code,{children:"tags"})," list itself is entirely replaced or removed, for example by doing the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// completely resets the `tags` list\nperson.set('tags', []);\n"})}),"\n",(0,a.jsx)(t.p,{children:"Is that inconvenient or unintuitive? Maybe, when getting started. But in practice, this level of granularity encourages efficient reactivity subscriptions which align with similarly granular component structure. That's a lot of buzzwords, but here's what I mean..."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"Even if this behavior seems unpalatable to you, I strongly suggest trying it out in real life for a bit if Verdant otherwise seems appealing for your project. After some acclimation, it becomes second nature."}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Verdant's reactivity subscription system encourages component structure ",(0,a.jsx)(t.em,{children:"less like this:"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:'// WARNING: do not take directions from this code! Verdant is not designed\n// to work this way and many parts of the below UI are non-reactive!\nfunction PersonView({ person }: { person: Person }) {\n\tconst { name, avatar, tags } = hooks.useWatch(person);\n\n\treturn (\n\t\t<Box d="col">\n\t\t\t<Box>\n\t\t\t\t<img src={avatar?.url} /> <span>{name}</span>\n\t\t\t</Box>\n\t\t\t<Box>\n\t\t\t\t{tags.map((tag) => (\n\t\t\t\t\t<Tag key={tag}>{tag}</Tag>\n\t\t\t\t))}\n\t\t\t</Box>\n\t\t</Box>\n\t);\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"And more like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:'function PersonAvatarView({ avatar }: { avatar: PersonAvatar }) {\n\tconst url = hooks.useWatch(avatar);\n\tif (!url) return null;\n\treturn <img src={url} />;\n}\n\nfunction PersonTagsView({ tags }: { tags: PersonTags }) {\n\tconst values = hooks.useWatch(tags);\n\treturn (\n\t\t<Box>\n\t\t\t{values.map((tag) => (\n\t\t\t\t<Tag key={tag}>{tag}</Tag>\n\t\t\t))}\n\t\t</Box>\n\t);\n}\n\nfunction PersonView({ person }: { person: Person }) {\n\tconst { name, avatar, tags } = hooks.useWatch(person);\n\n\treturn (\n\t\t<Box d="col">\n\t\t\t<Box>\n\t\t\t\t<PersonAvatarView avatar={avatar} />\n\t\t\t\t<span>{name}</span>\n\t\t\t</Box>\n\t\t\t<PersonTagsView tags={tags} />\n\t\t</Box>\n\t);\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Now, you may be thinking, this is silly, that's way more code. And that's true, but you also end up with reusable components which are naturally aligned to reactive boundaries so that any changes to data only re-render components which directly depend on them. Rather than all of ",(0,a.jsx)(t.code,{children:"PersonView"})," re-rendering whenever you modify the Person document in any way, you will now see only the ",(0,a.jsx)(t.code,{children:"PersonTagsView"})," component re-renders when a tag is added, for example."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["There's one other strong recommendation I'd make to support this kind of coding, which is to let go of the ",(0,a.jsx)(t.a,{href:"https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/no-multi-comp.md",children:"one-component per file"}),' rule and embrace multiple small supporting components in one file with a single exported component instead. This reaps the benefits of granular, single-purpose components without cluttering your file structure or exposing "reusable" components to the project which are better off being private and single-use.']}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This kind of optimization is unnecessary for something of the scale demonstrated in these examples, but since Verdant uses a document-centric model, for serious applications you will generally see the size and complexity of documents scale up as the app matures. Verdant's reactivity tracking approach helps reduce gradual performance degradation as you add data to your documents."}),"\n",(0,a.jsx)(t.h3,{id:"tip-fine-grained-watching",children:"Tip: Fine-grained watching"}),"\n",(0,a.jsxs)(t.p,{children:["When you read properties from the returned value of ",(0,a.jsx)(t.code,{children:"useWatch"}),", Verdant records which ones you access and only re-renders for changes to those properties! So if you only write ",(0,a.jsx)(t.code,{children:"const { name } = hooks.useWatch(person)"}),", the component will only re-render if ",(0,a.jsx)(t.code,{children:"name"})," changes and ignore all other fields."]}),"\n",(0,a.jsxs)(t.p,{children:["If you don't access the returned value, and just call ",(0,a.jsx)(t.code,{children:"hooks.useWatch(person)"})," bare, all direct fields will be watched by default."]}),"\n",(0,a.jsxs)(t.p,{children:["If you want to bypass this auto-granularity for some reason, just avoid accessing properties on the returned value, and instead read them from the watched entity with ",(0,a.jsx)(t.code,{children:".get"})," as needed. This will trigger the default watch on all fields."]}),"\n",(0,a.jsx)(t.h3,{id:"tip-use-the-named-generated-types",children:"Tip: Use the named generated types"}),"\n",(0,a.jsx)(t.p,{children:"Verdant CLI generates named type aliases for every field in your schema! This is tremendously convenient for typing props in granular React components. To get full use from these types, it's worth knowing a few conventions for how they are named:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["For object property fields, the name is just concatenated: ",(0,a.jsx)(t.code,{children:"Person.name"})," = ",(0,a.jsx)(t.code,{children:"PersonName"}),", ",(0,a.jsx)(t.code,{children:"Post.metadata.location.longitude"})," = ",(0,a.jsx)(t.code,{children:"PostMetadataLocationLongitude"}),", etc."]}),"\n",(0,a.jsxs)(t.li,{children:["For list fields, the ",(0,a.jsx)(t.code,{children:"Item"})," suffix is used to name the item types: ",(0,a.jsx)(t.code,{children:"Person.tags[0]"})," = ",(0,a.jsx)(t.code,{children:"PersonTagsItem"}),", ",(0,a.jsx)(t.code,{children:"Post.comments[0].title"})," = ",(0,a.jsx)(t.code,{children:"PostCommentsItemTitle"}),", etc."]}),"\n",(0,a.jsxs)(t.li,{children:["For map fields, the ",(0,a.jsx)(t.code,{children:"Value"})," suffix is used to name the value types: ",(0,a.jsx)(t.code,{children:"Post.attributes.get('foo')"})," = ",(0,a.jsx)(t.code,{children:"PostAttributesValue"}),", etc."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["As hinted above, even primitive fields are given named alias types. I recommend using these types to make it clear that a component is representing a particular field, even if it resolves to ",(0,a.jsx)(t.code,{children:"string"})," or another primitive. Ultimately it will depend on how reusable that component is expected to be across different purposes!"]}),"\n",(0,a.jsx)(t.h2,{id:"deep-watching",children:"Deep watching"}),"\n",(0,a.jsx)(t.p,{children:"I've explained granular watching first because that's the encouraged approach. But yes, you can watch all deep changes in an entity and sub-fields."}),"\n",(0,a.jsxs)(t.p,{children:["Just pass ",(0,a.jsx)(t.code,{children:"{ deep: true }"})," as a second parameter to ",(0,a.jsx)(t.code,{children:"useWatch"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"This turns off the granular reactivity tracking mentioned in the tip above. Your component will now re-render for every change in every sub-level of the watched entity. Don't say I didn't warn you!"}),"\n",(0,a.jsx)(t.h2,{id:"watching-files",children:"Watching files"}),"\n",(0,a.jsxs)(t.p,{children:["File fields will lazily load their file contents, so they also require reactivity. If you pass a file entity to ",(0,a.jsx)(t.code,{children:"useWatch"}),", it will return the URL of the file, or ",(0,a.jsx)(t.code,{children:"null"})," if it's not yet ready. This differs from how loading is handled with Suspense in most of Verdant (whoops)."]}),"\n",(0,a.jsx)(t.h2,{id:"handling-nullability",children:"Handling nullability"}),"\n",(0,a.jsxs)(t.p,{children:["Null values will always present some awkwardness, especially when trying to navigate the Rules of Hooks. You can't preemptively ",(0,a.jsx)(t.code,{children:"return null;"})," from a React component if your optional field doesn't exist, and then go on to call ",(0,a.jsx)(t.code,{children:"useWatch"})," later if it does! Verdant has specific but rather implicit behaviors with null values you should know about which help make things a bit less unwieldy."]}),"\n",(0,a.jsxs)(t.p,{children:["You can pass a nullable value to ",(0,a.jsx)(t.code,{children:"useWatch"}),". This is a no-op and returns ",(0,a.jsx)(t.code,{children:"null"}),". The Typescript typing of ",(0,a.jsx)(t.code,{children:"useWatch"})," will automatically switch to the ",(0,a.jsx)(t.code,{children:"T | null"})," return type when you pass a nullable parameter to it to remind you of this."]}),"\n",(0,a.jsx)(t.p,{children:"Because nullable parameters result in nullable returned values, you can no longer utilize the destructuring pattern shown in prior examples. Here are some alternative patterns for reading reactive data from the entity if it exists:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"// since we can't depend on a return value from this hook...\nhooks.useWatch(maybeNullPerson);\n\n// we can still take the returned value but not destructure, and conditionally read from it\nconst value = hooks.useWatch(maybeNullPerson);\nconst name = value?.name;\n\n// or we can use getAll() to 'destructure' the entity and hardcode fallbacks...\nconst { name, avatar, tags } = maybeNullPerson?.getAll() || {\n\tname: '',\n\tavatar: null,\n\ttags: null,\n};\n\n// or we can just read the values directly\nconst name = maybeNullPerson?.get('name');\nconst avatar = maybeNullPerson?.get('avatar');\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Since ",(0,a.jsx)(t.code,{children:"useWatch"})," takes care of subscribing to entity changes if the entity is not null, you can rely on it to re-render the component for you. You're free to use ",(0,a.jsx)(t.code,{children:".get"})," to read data. Normally ",(0,a.jsx)(t.code,{children:".get"})," does not provide reactivity, but again, ",(0,a.jsx)(t.code,{children:"useWatch"})," is handling that bit."]}),"\n",(0,a.jsx)(t.h2,{id:"null-handling-by-example",children:"Null handling by example"}),"\n",(0,a.jsx)(t.p,{children:"To explore null handling in practice, let's consider what happens if you have a nullable object field and you want to watch it for changes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const posts = schema.collection({\n\tname: 'post',\n\tprimaryKey: 'id',\n\tfields: {\n\t\tid: schema.fields.id(),\n\t\ttitle: schema.fields.string(),\n\t\tattachment: schema.fields.object({\n\t\t\tproperties: {\n\t\t\t\tpurpose: schema.fields.string(),\n\t\t\t\tfile: schema.fields.file(),\n\t\t\t},\n\t\t\t// the \"attachment\" field on the Post document can be set to `null`\n\t\t\tnullable: true,\n\t\t}),\n\t},\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"Let's write a component that takes a Post document and renders a UI to display the attachment, if present."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"function MaybePostAttachment({ post }: { post: Post }) {\n\t// start by observing changes to the identity of the attachment field\n\tconst { attachment } = hooks.useWatch(post);\n\t// using the bare useWatch to observe attachment, if it exists\n\thooks.useWatch(attachment);\n\t// pulling out file from the attachment (if present) so\n\t// we can observe that, too\n\tconst file = attachment?.get('file');\n\t// once again, bare useWatch on a file which may be null.\n\thooks.useWatch(file);\n\n\t// if attachment doesn't exist, we can now conditionally exit.\n\tif (!attachment) return null;\n\n\t// if it does, we can use .get to render its properties.\n\t// the useWatch usage above will re-render this component as needed\n\treturn (\n\t\t<div>\n\t\t\t<img src={file?.url} />\n\t\t\t<span>{attachment.get('purpose')}</span>\n\t\t</div>\n\t);\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This is a functional and reasonable approach, if a little awkward with all the ",(0,a.jsx)(t.code,{children:"?."})," usage required. If this optionality gets tedious, you can always start breaking up component boundaries:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-tsx",children:"function MaybePostAttachment({ post }: { post: Post }) {\n\tconst { attachment } = hooks.useWatch(post);\n\n\tif (!attachment) return null;\n\n\treturn <PostAttachmentView attachment={attachment} />;\n}\n\nfunction PostAttachmentView({ attachment }: { attachment: PostAttachment }) {\n\tconst { file, purpose } = hooks.useWatch(attachment);\n\thooks.useWatch(file);\n\n\treturn (\n\t\t<div>\n\t\t\t<img src={file?.url} />\n\t\t\t<span>{purpose}</span>\n\t\t</div>\n\t);\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"I think this second version is much cleaner, but it's not always worth it to break things down this way. While I'm still prototyping a feature, my components will look more like the first one until I decide on how I want to engineer it. Do what feels right!"}),"\n",(0,a.jsx)(t.h2,{id:"null-handling-works-for-root-documents-too",children:"Null handling works for root documents, too"}),"\n",(0,a.jsxs)(t.p,{children:["All of the above applies not just to nullable fields, but also missing documents. Single-value queries can return ",(0,a.jsx)(t.code,{children:"null"})," if no document matches, and the Typescript typings reflect this fact. You can pass this maybe-null document to ",(0,a.jsx)(t.code,{children:"useWatch"})," just like anything else."]}),"\n",(0,a.jsx)(t.h2,{id:"bypassing-the-react-lifecycle",children:"Bypassing the React lifecycle"}),"\n",(0,a.jsx)(t.p,{children:"Sometimes you may want to get a callback when an entity changes, but not re-render your component. Perhaps the change isn't part of the rendering, like a side effect. Or maybe it changes too frequently and you want more control (like in a 2D canvas)."}),"\n",(0,a.jsxs)(t.p,{children:["You can use ",(0,a.jsx)(t.code,{children:"useOnChange"})," for that! It works just like ",(0,a.jsx)(t.code,{children:"useWatch"}),", but the second parameter is a callback. The callback is called with a parameter ",(0,a.jsx)(t.code,{children:"{ isLocal?: boolean }"})," which will tell you if the change originated from the local replica. To read the new data, you should just access the entity itself with ",(0,a.jsx)(t.code,{children:".get"})," and other methods."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"hooks.useOnChange(person, () => {\n\tconsole.log(person.get('name'));\n});\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"useOnChange"})," doesn't have granular watching, so if you only want to respond to changes to a single field or subset of fields, you'll have to track those yourself. Alternatively, you can eject from these provided React hooks and build your own using the ",(0,a.jsx)(t.a,{href:"/docs/local-storage/entities#subscribing-to-changes",children:"vanilla reactivity"})," events and ",(0,a.jsx)(t.code,{children:"useEffect"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["The third parameter of ",(0,a.jsx)(t.code,{children:"useOnChange"})," is ",(0,a.jsx)(t.code,{children:"{ deep?: boolean }"}),", which lets you watch deep changes with this hook, too."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},6039:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(8225);const a={},o=s.createContext(a);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);