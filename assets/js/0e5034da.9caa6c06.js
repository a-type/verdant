"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6865],{3534:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"react/queries","title":"Query hooks","description":"Query hooks for each collection in your schema are generated by the CLI with specific names. See sections below for a more detailed API.","source":"@site/docs/react/queries.md","sourceDirName":"react","slug":"/react/queries","permalink":"/docs/react/queries","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Getting started with React","permalink":"/docs/react/generation"},"next":{"title":"Reactivity","permalink":"/docs/react/reactivity"}}');var i=n(1273),o=n(8576);const a={sidebar_position:2},r="Query hooks",l={},d=[{value:"Suspense",id:"suspense",level:2},{value:"Opting out of Suspense",id:"opting-out-of-suspense",level:3},{value:"Query hook types in-depth",id:"query-hook-types-in-depth",level:2},{value:"<code>use___</code>",id:"use___",level:3},{value:"<code>useOne___</code>",id:"useone___",level:3},{value:"<code>useAll___</code>",id:"useall___",level:3},{value:"<code>useAll___Paginated</code>",id:"useall___paginated",level:3},{value:"<code>useAll___Infinite</code>",id:"useall___infinite",level:3},{value:"Query reactivity",id:"query-reactivity",level:2},{value:"Query keys and identity",id:"query-keys-and-identity",level:2},{value:"Sharing keys to reference the same query in different places",id:"sharing-keys-to-reference-the-same-query-in-different-places",level:3},{value:"Query disposal and keep-alive",id:"query-disposal-and-keep-alive",level:2},{value:"Keep-alive outside React hooks",id:"keep-alive-outside-react-hooks",level:3}];function c(e){const t={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"query-hooks",children:"Query hooks"})}),"\n",(0,i.jsx)(t.p,{children:"Query hooks for each collection in your schema are generated by the CLI with specific names. See sections below for a more detailed API."}),"\n",(0,i.jsxs)(t.p,{children:["For example, if you have a collection named ",(0,i.jsx)(t.code,{children:"todoItems"}),", you will get these query hooks:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"useTodoItem"}),": Retrieves one document. You pass in an id."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"useOneTodoItem"}),": pass an index query to filter the list of returned items, and only take the first match."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"useAllTodoItems"}),": pass an index query to filter the list of returned items."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"useAllTodoItemsPaginated"}),": pass an index query to filter the list of returned items. Paginates data according to the ",(0,i.jsx)(t.code,{children:"pageSize"})," parameter. When the next page is fetched, the prior page is discarded. Good for paginated interfaces. Returns a tuple: ",(0,i.jsx)(t.code,{children:"[page, tools]"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"useAllTodoItemsInfinite"}),": pass an index query to filter the list of returned items. Paginates data according to the ",(0,i.jsx)(t.code,{children:"pageSize"})," parameter, but appends newly fetched pages to the end of the list instead of replacing the returned set. Good for infinite scrolling lists. Returns a tuple: ",(0,i.jsx)(t.code,{children:"[itemsSoFar, tools]"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"suspense",children:"Suspense"}),"\n",(0,i.jsx)(t.p,{children:"The hooks use Suspense so that you don't have to write loading state conditional code in your components. All hooks return data directly. If the data is not ready, they suspend."}),"\n",(0,i.jsxs)(t.p,{children:["Wrap your app in a ",(0,i.jsx)(t.code,{children:"<Suspense>"})," to handle this. You can create multiple layers of Suspense to handle loading more granularly."]}),"\n",(0,i.jsx)(t.h3,{id:"opting-out-of-suspense",children:"Opting out of Suspense"}),"\n",(0,i.jsxs)(t.p,{children:["In addition to just not liking Suspense, there are various reasons you may want to opt out for specific queries. Each query hook has an equivalent hook with the word ",(0,i.jsx)(t.code,{children:"Unsuspended"})," appended to the name. These hooks will return ",(0,i.jsx)(t.code,{children:"{ data, status }"})," instead of the dataset directly. ",(0,i.jsx)(t.code,{children:"data"})," will be ",(0,i.jsx)(t.code,{children:"null"})," for single-item queries and ",(0,i.jsx)(t.code,{children:"[]"})," for list queries, until ",(0,i.jsx)(t.code,{children:"status"})," is ",(0,i.jsx)(t.code,{children:'"ready"'}),". Possible ",(0,i.jsx)(t.code,{children:"status"})," values are: ",(0,i.jsx)(t.code,{children:'"initial", "initializing", "revalidating", and "ready"'}),"."]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"NOTE:"})," presently, there are no Unsuspended versions of paginated queries. Let me know if you really need those in a Github issue."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"query-hook-types-in-depth",children:"Query hook types in-depth"}),"\n",(0,i.jsx)(t.h3,{id:"use___",children:(0,i.jsx)(t.code,{children:"use___"})}),"\n",(0,i.jsxs)(t.p,{children:["Pass a document's primary key to load it. If the document does not exist, returns ",(0,i.jsx)(t.code,{children:"null"}),". Keep in mind that if you know the primary key ahead of time, a document may not be available until it is synced from a peer. You should always handle the ",(0,i.jsx)(t.code,{children:"null"})," case."]}),"\n",(0,i.jsx)(t.h3,{id:"useone___",children:(0,i.jsx)(t.code,{children:"useOne___"})}),"\n",(0,i.jsxs)(t.p,{children:["Use an index filter to select the first matching document. If no filter is passed, an arbitrary document is returned. Returns ",(0,i.jsx)(t.code,{children:"null"})," if no matching document exists."]}),"\n",(0,i.jsx)(t.h3,{id:"useall___",children:(0,i.jsx)(t.code,{children:"useAll___"})}),"\n",(0,i.jsx)(t.p,{children:"Load all documents, or use an index filter to load a subset. Returns all matched documents as an array."}),"\n",(0,i.jsx)(t.h3,{id:"useall___paginated",children:(0,i.jsx)(t.code,{children:"useAll___Paginated"})}),"\n",(0,i.jsx)(t.p,{children:'Load a page of documents, with or without an index filter. Returns a tuple. The first tuple value is an array of documents representing the current page. The second value is an object of "tools" for manipulating pagination:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'{\n\tstatus,      // the query status (initial, initializing, ready, revalidating)\n\t             // this will be "revalidating" while a new page is being fetched\n  hasNext,     // a boolean indicating if a next page is available\n\thasPrevious, // a boolean indicating if a previous page is available\n\tnext,        // call this function to advance to the next page (no-op if none exists)\n\tprevious,    // call this function to go back to the previous page (no-op if none exists)\n\tsetPage,     // call this with a page index to jump to a page\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"useall___infinite",children:(0,i.jsx)(t.code,{children:"useAll___Infinite"})}),"\n",(0,i.jsx)(t.p,{children:'Loads a page of documents, with or without an index filter. When additional pages are loaded, they are appended to the result set, rather than replacing it. Returns a tuple. The first tuple value is an array of documents representing the current page. The second value is an object of "tools" for manipulating pagination:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'{\n\tstatus,      // the query status (initial, initializing, ready, revalidating)\n\t             // this will be "revalidating" while a new page is being fetched\n\thasMore,     // a boolean indicating if more data is available to load\n\tloadMore,    // call this function to load the next page of data\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"query-reactivity",children:"Query reactivity"}),"\n",(0,i.jsxs)(t.p,{children:["When using hooks to run queries in React, the hook will only re-render your React component when the ",(0,i.jsx)(t.em,{children:"set of documents returned by the query"})," changes. It will not re-render your component if the contents of those documents change; to monitor document data, you should pass a document to ",(0,i.jsx)(t.code,{children:"useWatch"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"query-keys-and-identity",children:"Query keys and identity"}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"TL;DR"}),": When query index filters are dynamic, pass ",(0,i.jsx)(t.code,{children:"key"})," to the hook to prevent memory and CPU waste or unexpected React suspense triggering."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"React bindings for Verdant queries provide a high level of convenience for altering query index filters on the fly, but there are caveats."}),"\n",(0,i.jsx)(t.p,{children:"Consider the following example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:"const [inputValue, setInputValue] = useState('');\nconst posts = hooks.useAllPosts({\n\tindex: {\n\t\twhere: 'titleMatch',\n\t\teq: inputValue,\n\t},\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["If ",(0,i.jsx)(t.code,{children:"inputValue"})," is connected to a user-facing input, as the user types, this value will change rapidly. Because the filter of the query changes, its automatically computed cache key will also change, so the prior query will actually be discarded with each keystroke. This is wasteful!"]}),"\n",(0,i.jsxs)(t.p,{children:["To prevent this, you should pass a ",(0,i.jsx)(t.code,{children:"key"})," value to the hook. When a ",(0,i.jsx)(t.code,{children:"key"})," is specified, the query is retained and its filter is updated, instead of launching a new query. Your ",(0,i.jsx)(t.code,{children:"key"})," should be unique to the component / usage context of this particular query. For example, ",(0,i.jsx)(t.code,{children:'"postsFilteredByInput"'})," might be a good key for the example above."]}),"\n",(0,i.jsxs)(t.p,{children:["In the future, default key value behavior and/or the optionality of ",(0,i.jsx)(t.code,{children:"key"})," in these hooks may change. I'm still working on the ergonomics."]}),"\n",(0,i.jsx)(t.h3,{id:"sharing-keys-to-reference-the-same-query-in-different-places",children:"Sharing keys to reference the same query in different places"}),"\n",(0,i.jsxs)(t.p,{children:["Since queries are cached by key, once you've specified a ",(0,i.jsx)(t.code,{children:"key"})," value for a query hook somewhere, using the same key elsewhere will immediately load the in-memory cached query. You can exploit this to move queries downward in your React tree without performance loss: rather than have one query at the top of the app for commonly used data and passing that down, you can encapsulate this query in a reusable hook with a hardcoded key and call it freely from any component in your app."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"export function useFilteredPosts() {\n\t// this is just for example's sake, suppose we have a search string provided\n\t// by some app context state to use.\n\tconst { filterValue } = useFilterContext();\n\treturn hooks.useAllPosts({\n\t\tindex: {\n\t\t\twhere: 'titleMatch',\n\t\t\teq: filterValue,\n\t\t},\n\t\tkey: 'filteredPosts',\n\t});\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Don't overdo it"})," -- be careful not to reuse the same key if different subscribers to this query may expect different data, for example if a different filter value is supplied in different parts of the app. Once a key is applied, all usages of query hooks using that key will receive the exact same data."]}),"\n",(0,i.jsx)(t.h2,{id:"query-disposal-and-keep-alive",children:"Query disposal and keep-alive"}),"\n",(0,i.jsxs)(t.p,{children:["Utilizing ",(0,i.jsx)(t.code,{children:"client.queries.keepAlive"})," can help manage query disposal behavior. Normally, once a React component which used a query is unmounted, if no other subscribing components exist, the query will be disposed after 5 seconds. Remounting that component later will require reloading the entire query from disk."]}),"\n",(0,i.jsxs)(t.p,{children:["To prevent this disposal, you can use ",(0,i.jsx)(t.code,{children:"client.queries.keepAlive"}),", passing in the query's ",(0,i.jsx)(t.code,{children:"key"}),". This is best done with custom keys."]}),"\n",(0,i.jsxs)(t.p,{children:["A good place to put ",(0,i.jsx)(t.code,{children:"keepAlive"})," might be in a top-level route component in a nested route structure. For example, suppose you have a route structure of ",(0,i.jsx)(t.code,{children:"/posts/:postId"}),". In your ",(0,i.jsx)(t.code,{children:"/posts"})," page, you query all posts with a filter, but on the ",(0,i.jsx)(t.code,{children:"/posts/:postId"})," page, the component which performed that query is unmounted to show the individual post. In this case, when users view a specific post for more than 5 seconds, the filtered post query is unloaded. When they navigate back to ",(0,i.jsx)(t.code,{children:"/posts"}),", the app has to re-fetch the posts list."]}),"\n",(0,i.jsxs)(t.p,{children:["You can optimize this by keeping the posts list query in memory with a keep-alive. Find a common ancestor React component which remains mounted on both the ",(0,i.jsx)(t.code,{children:"/posts"})," and ",(0,i.jsx)(t.code,{children:"/posts/:postId"})," pages, and include something like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const client = hooks.useClient();\nuseEffect(() => {\n\tclient.queries.keepAlive('postsList');\n\treturn () => client.queries.dropKeepAlive('postsList');\n}, [client]);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This ",(0,i.jsx)(t.code,{children:"useEffect"})," will mark a keep-alive hold on the query with the key ",(0,i.jsx)(t.code,{children:"postsList"})," while the component is mounted, then remove the hold after it unmounts. As long as this hook is run in a component which stays mounted on both route paths, users can remain on the post page as long as they want and the post list query will remain fresh."]}),"\n",(0,i.jsx)(t.p,{children:"Keep in mind that you shouldn't just put this at the global app level, unless you're ok with the post list query remaining in-memory indefinitely. Where you place this hook makes all the difference."}),"\n",(0,i.jsx)(t.p,{children:"You could also place this hook within the post page component! As long as there is less than 5 seconds between the posts list unmounting and the post page mounting, the keep alive should come into effect before the list query is disposed."}),"\n",(0,i.jsx)(t.h3,{id:"keep-alive-outside-react-hooks",children:"Keep-alive outside React hooks"}),"\n",(0,i.jsx)(t.p,{children:"The example above uses React hooks to place and remove keep-alive holds. You can also reference the client directly with a query key to do this. Keep in mind you need a reference to the resolved, initialized Client, not the ClientDescriptor. React normally uses Suspense to avoid thinking about that, but if you need the Client outside React, you'll need something like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const client = await clientDesc.open();\nclient.queries.keepAlive('some-key');\n"})}),"\n",(0,i.jsx)(t.p,{children:"This is true of Verdant vanilla JS usage generally, but since you're in the React docs you may not be aware of that."}),"\n",(0,i.jsxs)(t.p,{children:["I'm looking into ways of removing this extra ",(0,i.jsx)(t.code,{children:"await"})," step since it's very inconvenient."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8576:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(3917);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);