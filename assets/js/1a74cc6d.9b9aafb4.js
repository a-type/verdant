"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2688],{2129:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"sync/server","title":"Sync Server","description":"Verdant doesn\'t sync by default. It\'s offline-first, sync-optional. I built it that way because my goal is to support nice local-only anonymous experiences, and add sync & realtime on as an incentive to sign up (and potentially subscribe) to your app.","source":"@site/docs/sync/server.md","sourceDirName":"sync","slug":"/sync/server","permalink":"/docs/sync/server","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Sync","permalink":"/docs/category/sync"},"next":{"title":"Authenticating Sync","permalink":"/docs/sync/authentication"}}');var o=n(1273),s=n(8576);const i={sidebar_position:1},a="Sync Server",c={},l=[{value:"Quickstart",id:"quickstart",level:2},{value:"A real server",id:"a-real-server",level:2},{value:"Profiles",id:"profiles",level:2},{value:"Evicting libraries from server storage",id:"evicting-libraries-from-server-storage",level:2},{value:"Using eviction for contingency scenarios",id:"using-eviction-for-contingency-scenarios",level:3}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"sync-server",children:"Sync Server"})}),"\n",(0,o.jsx)(t.p,{children:"Verdant doesn't sync by default. It's offline-first, sync-optional. I built it that way because my goal is to support nice local-only anonymous experiences, and add sync & realtime on as an incentive to sign up (and potentially subscribe) to your app."}),"\n",(0,o.jsx)(t.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,o.jsx)(t.p,{children:"Verdant provides a simple CLI server which can be used to try out sync and prototype. It's not recommended to deploy this server or use it in a production capacity, as it completely ignores authentication and authorization."}),"\n",(0,o.jsx)(t.p,{children:"To use this server, run:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"verdant-server --port 3242\n"})}),"\n",(0,o.jsxs)(t.p,{children:["No options are required. ",(0,o.jsx)(t.code,{children:"--port"})," sets a port, ",(0,o.jsx)(t.code,{children:"--secret"})," sets a token signing secret (the default one is not at all secure)."]}),"\n",(0,o.jsxs)(t.p,{children:["This server will store data in a SQLite database file called ",(0,o.jsx)(t.code,{children:"verdant.sqlite"})," in the current directory."]}),"\n",(0,o.jsx)(t.p,{children:"To connect to your prototyping sync server, pass the following options to your Verdant client descriptor constructor (the server CLI also outputs instructions for this):"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"import { cliSync } from '@verdant-web/store';\n\nconst clientDesc = new ClientDescriptor({\n\tnamespace: 'whatever',\n\tsync: cliSync('<a library id>'),\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"libraryId"})," can be anything. Users connected to the same library sync together. You might put it in the URL path or something."]}),"\n",(0,o.jsx)(t.h2,{id:"a-real-server",children:"A real server"}),"\n",(0,o.jsx)(t.p,{children:"To start syncing in production scenarios, you must first host a server."}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Tip:"})," using Cloudflare? Verdant now supports Cloudflare via a separate ",(0,o.jsx)(t.a,{href:"/docs/sync/cloudflare",children:"adapter"})]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"A Node server requires a few things:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"A SQLite database directory to store data"}),"\n",(0,o.jsx)(t.li,{children:"An authorization function which it uses to determine connected client identity and library access"}),"\n",(0,o.jsx)(t.li,{children:"Optional: an interface implementation to provide more detailed user profile information for presence features"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Verdant's Node server implementation is based on Hono, a nice little HTTP server framework. Some assembly is required."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"import { createHttpRouter, createNodeWebsocketHandler } from '@verdant-web/server/node';\nimport { sqlShardStorage } from '@verdant-web/server/storage';\nimport { LocalFileStorage, TokenProvider, createVerdant } from '@verdant-web/server';\n\n// for the Hono server parts\nimport { serve } from '@hono/node-server';\nimport { serveStatic } from '@hono/node-server/serve-static';\n\n// the \"core\" is a service API for interacting with libraries.\n// you could plug this into your own HTTP or other kind of interface,\n// but further on are some Hono-based tools to help get started.\nconst core = createVerdant({\n\t// SQLite databases for each library are stored in this directory\n\tstorage: sqlShardStorage({\n\t\tdatabasesDirectory: 'verdant-dbs',\n\t}),\n\t// implement .get to retrieve detailed profile information for sync users\n\tprofiles: {\n\t\tget: async (userId) => {\n\t\t\t// you could fetch a profile record from a database here to augment\n\t\t\t// this profile with name, image, etc.\n\t\t\t// values will be cached, so don't worry too much about timing.\n\t\t\treturn { id: userId };\n\t\t},\n\t},\n\t// required to validate sync access tokens generated from\n\t// your API\n\ttokenSecret: process.env.TOKEN_SECRET,\n\t// optional; enables file sync\n\tfileStorage: new LocalFileStorage({\n\t\trootDirectory: 'verdant-files',\n\t\t// this matches an API you must host (see below)\n\t\thost: `http://localhost:${port}/files`,\n\t}),\n\t// optional logger\n\tlog: (level, ...args) => console.log(level, ...args),\n})\n\n// our verdant router will be mounted to a subpath\n// and handle all HTTP sync requests\nconst verdantRouter = createHttpRouter(core);\n\nconst tokenProvider = new TokenProvider({\n\tsecret: process.env.TOKEN_SECRET,\n});\n\n// this is \"your\" app -- Verdant lives in it,\n// but you control the API.\nconst app = new Hono()\n\t.route('/verdant', verdantRouter)\n\t// issue sync tokens\n\t.get('/auth/:libraryId', async (ctx) => {\n\t\t// here you authenticate your user, authorize\n\t\t// their access to a particular library, and\n\t\t// issue a token.\n\t\tconst library = ctx.req.param('libraryId');\n\n\t\tconst user = // your own session / auth logic here\n\n\t\t// remember to check that the user is allowed to sync\n\t\t// to this library\n\n\t\tconst token = tokenProvider.getToken({\n\t\t\tlibraryId: library,\n\t\t\tuserId: user,\n\t\t\t// this subpath matches the verdantRouter mount\n\t\t\tsyncEndpoint: `http://127.0.0.1:${port}/verdant`,\n\t\t});\n\t\treturn ctx.json({\n\t\t\taccessToken: token,\n\t\t});\n\t})\n\t// (optional) serve uploaded files\n\t// if you use LocalFileStorage\n\t.get('/files/*', serveStatic({\n\t\troot: 'verdant-files',\n\t\trewriteRequestPath: (path) => path.replace('/files/', ''),\n\t}));\n\nconst server = serve({\n\tfetch: app.fetch,\n\tport\n});\n\n// handle websocket sync! must be done like this, not included\n// in createHttpRouter!\nconst onUpgrade = createNodeWebsocketHandler(core);\nserver.addListener('upgrade', onUpgrade);\n\nserver.addListener('listening', () => {\n\tconsole.info(`\ud83c\udf3f Verdant Server listening on http://localhost:${port}`);\n});\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now, you might think that's a lot of work. That's fair. But the pieces are purposefully a little componentized / low level to keep things adaptable. You can swap out your file storage and integrate Verdant into an existing Hono app or extend the boilerplate above with your own APIs. You also have control over where Verdant mounts, what authorization is applied to libraries, who users are, etc."}),"\n",(0,o.jsx)(t.h2,{id:"profiles",children:"Profiles"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"profiles"})," configuration option accepts anything that implements the profiles interface - which is just a ",(0,o.jsx)(t.code,{children:"get(userId)"})," function. It can return any data your app permanently associates with a particular user. This data is utilized in the ",(0,o.jsx)(t.a,{href:"./presence",children:"presence"})," system to give clients access to read-only, trusted information about particular users. A default name is recommended if you have one for your user. A profile image is also a good idea!"]}),"\n",(0,o.jsx)(t.h2,{id:"evicting-libraries-from-server-storage",children:"Evicting libraries from server storage"}),"\n",(0,o.jsxs)(t.p,{children:["In keeping with the Verdant principle of ",(0,o.jsx)(t.a,{href:"../manifesto",children:"matching infrastructure cost with user revenue"}),', the server lets you selectively "evict" libraries from storage.']}),"\n",(0,o.jsx)(t.p,{children:"You can evict libraries when a user ends their subscription. This will free up space in your database without disrupting the user's local copy of their data."}),"\n",(0,o.jsx)(t.p,{children:"If the user decides to subscribe again, you don't need to do anything - whenever they sync again, the server will be sure to restore the library from their replica."}),"\n",(0,o.jsxs)(t.p,{children:["To evict a library, just call ",(0,o.jsx)(t.code,{children:"core.evict('library-id')"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"using-eviction-for-contingency-scenarios",children:"Using eviction for contingency scenarios"}),"\n",(0,o.jsx)(t.p,{children:"Although I've done a lot of testing to try to make Verdant as consistent and reliable as possible under a variety of circumstances, I can never guarantee it's bug-free."}),"\n",(0,o.jsx)(t.p,{children:"You may reach a situation where a user reaches out about problems with sync. Maybe devices are not consistent, or changes are being reverted."}),"\n",(0,o.jsxs)(t.p,{children:["The first thing to check would be that the user has the latest version of your client code. But after that, you could expose an admin-only endpoint on your server which calls ",(0,o.jsx)(t.code,{children:"core.evict"}),". This may seem dangerous, but it's pretty safe! The user will need to reconnect with a device which has a good copy of their data to restore their library to the server. If they're already connected to sync when you do this, their device will reconnect and reupload automatically."]}),"\n",(0,o.jsx)(t.p,{children:"Other replicas which may have interacted with the library will be forced to reset back to this known state, so they'll lose any offline or out-of-sync changes -- but that's kind of the point; starting back at a clean slate."}),"\n",(0,o.jsx)(t.p,{children:"If this ever does happen to you, reach out with any details you can give me about what happened. Although I do feel better having these failsafes, I'd rather have Verdant be 100% reliable and bug-free."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8576:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(3917);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);