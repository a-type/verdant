"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1241],{2740:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"sync/files","title":"Synchronizing files","description":"When you create files locally, they are flagged as unsynced until you next go online.","source":"@site/docs/sync/files.md","sourceDirName":"sync","slug":"/sync/files","permalink":"/docs/sync/files","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Advanced: Transports","permalink":"/docs/sync/transports"},"next":{"title":"Pruning Invalid Data","permalink":"/docs/sync/pruning"}}');var s=t(1273),l=t(8576);const a={sidebar_position:7},r="Synchronizing files",o={},d=[{value:"Storing files",id:"storing-files",level:2},{value:"Serving files",id:"serving-files",level:2},{value:"When the server cleans up files",id:"when-the-server-cleans-up-files",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"synchronizing-files",children:"Synchronizing files"})}),"\n",(0,s.jsx)(n.p,{children:"When you create files locally, they are flagged as unsynced until you next go online."}),"\n",(0,s.jsx)(n.p,{children:"When going online, any file data which was unsynced is sent to the the server. If it fails to upload, depending on the response code, a retry will be scheduled later."}),"\n",(0,s.jsx)(n.p,{children:"If you're already online when a local file is created, it will be uploaded ASAP."}),"\n",(0,s.jsx)(n.p,{children:"Meanwhile, in parallel, the normal Verdant data sync protocol will synchronize any associated field which references that file. This means that peers may receive data about a file field before the client that created it has finished uploading the file itself, and well before that client can proceed to download it."}),"\n",(0,s.jsxs)(n.p,{children:["For this reason, you should always handle the ",(0,s.jsx)(n.code,{children:".loading === true"})," case on any EntityFile you use, and probably ",(0,s.jsx)(n.code,{children:".failed === true"})," as well in case the server has problems."]}),"\n",(0,s.jsx)(n.h2,{id:"storing-files",children:"Storing files"}),"\n",(0,s.jsxs)(n.p,{children:["You must provide a file storage backend to the server to sync files. This can be the default ",(0,s.jsx)(n.code,{children:"LocalFileStorage"})," backend which is exported from ",(0,s.jsx)(n.code,{children:"@verdant-web/server"}),", or you can implement the ",(0,s.jsx)(n.code,{children:"FileStorage"})," interface yourself to connect to a different file storage service (like S3, etc)."]}),"\n",(0,s.jsx)(n.p,{children:"If you don't supply a storage backend, syncing files will fail."}),"\n",(0,s.jsx)(n.h2,{id:"serving-files",children:"Serving files"}),"\n",(0,s.jsxs)(n.p,{children:["This may be a little confusing, honestly, but ",(0,s.jsx)(n.em,{children:"serving"})," files is up to you."]}),"\n",(0,s.jsxs)(n.p,{children:["Verdant handles ",(0,s.jsx)(n.em,{children:"uploading"})," files (via a ",(0,s.jsx)(n.code,{children:"FileStorage"})," implementation) and ",(0,s.jsx)(n.em,{children:"getting file metadata"}),". But the actual request to fetch the real file is something your infrastructure must implement."]}),"\n",(0,s.jsx)(n.p,{children:"This is left up to the user because there are many valid ways to deliver actual files, and the best one might depend on your app's needs. Perhaps you can serve them from a mounted disk volume, or via a public Cloudfront CDN, etc."}),"\n",(0,s.jsxs)(n.p,{children:["How this happens all depends on how your ",(0,s.jsx)(n.code,{children:"FileStorage"})," implementation works. Since ",(0,s.jsx)(n.code,{children:"FileStorage"}),"s aren't very large classes, I recommend reading the one you're using."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/a-type/verdant/blob/main/packages/server/src/files/FileStorage.ts#L30",children:"LocalFileStorage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/a-type/verdant/blob/main/packages/file-storage-s3/src/index.ts",children:"S3FileStorage"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/a-type/verdant/blob/main/packages/cloudflare/src/files.ts",children:"R2FileStorage"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Generally, when Verdant requests files, the request will be in the following format:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"<base file host>/:libraryId/:fileId/:fileName\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And FileStorage implementations usually expose the host as a parameter you provide. So if you have a Cloudfront set up at ",(0,s.jsx)(n.code,{children:"https://user-files.myapp.com"}),", your file request might look like ",(0,s.jsx)(n.code,{children:"https://user-files.myapp.com/library/file/filename.png"}),". If you're using the S3FileStorage implementation to put files in a bucket behind that Cloudfront instance, you're probably fine."]}),"\n",(0,s.jsx)(n.p,{children:"However, if you need to terminate file requests in your own server, you may have more work to do. Say instead you have a Cloudflare Worker API that streams the files from an R2 bucket. Your worker API might look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"app.get('/files/*', async (ctx) => {\n\tconst path = ctx.req.path.replace(/^\\/files\\//, '');\n\tconst obj = await ctx.env.FILES_BUCKET.get(path);\n\tif (!obj?.body) {\n\t\treturn ctx.text('not found', 404);\n\t}\n\treturn new Response(obj.body, {\n\t\theaders: {\n\t\t\t'Content-Type':\n\t\t\t\tobj.httpMetadata?.contentType || 'application/octet-stream',\n\t\t},\n\t});\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It's probably better to use wildcards like this rather than depend directly on the ",(0,s.jsx)(n.code,{children:":libraryId/:fileId/:filepath"})," convention, as I may want to change that at some point, so this keeps things decoupled."]}),"\n",(0,s.jsx)(n.h2,{id:"when-the-server-cleans-up-files",children:"When the server cleans up files"}),"\n",(0,s.jsx)(n.p,{children:"The server has a broader view of the overall sync status of the library, so it hangs onto files a little longer than clients and waits to be sure the file is officially pending deletion."}),"\n",(0,s.jsx)(n.p,{children:'"Officially pending deletion" means:'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The field associated with the file is deleted and all pending operations the server knows about have been applied to it"}),"\n",(0,s.jsx)(n.li,{children:"Since the field has been rebased to this state, that means all clients have acknowledged the deletion as it currently stands"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"However, these conditions don't guarantee the file field will not be restored by a client - specifically if there is an 'undo delete' operation waiting on a client's undo stack."}),"\n",(0,s.jsxs)(n.p,{children:["To guard against this contingency, the server only marks the file's metadata as ",(0,s.jsx)(n.code,{children:"pendingDeleteAt: <timestamp>"}),". The next time all replicas disconnect from the library, if the ",(0,s.jsx)(n.code,{children:"pendingDeleteAt"})," timestamp is older than 1 day, the file will be permanently deleted. This is a heuristic more than a guarantee, but it's a reasonable tradeoff against having to synchronize undo stack states."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8576:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(3917);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);