"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8439],{2967:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"local-storage/entities","title":"Documents & Entities","description":"Queries return Documents. A Document provides a .get method to retrieve properties, and a .set to set them - as well as other utility methods depending on its type. All root documents are Object Entities, which also provide .update. Since Documents can contain arbitrary sub-objects, you can retrieve lists off them, which comes as List Entities and provide some common list methods too.","source":"@site/docs/local-storage/entities.md","sourceDirName":"local-storage","slug":"/local-storage/entities","permalink":"/docs/local-storage/entities","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Indexes & Querying","permalink":"/docs/local-storage/querying"},"next":{"title":"Undo, Redo, and Batching","permalink":"/docs/local-storage/undo"}}');var n=t(1273),r=t(8576);const l={sidebar_position:5},o="Documents & Entities",c={},a=[{value:"Universal Entity behavior",id:"universal-entity-behavior",level:2},{value:"Subscribing to changes",id:"subscribing-to-changes",level:3},{value:"Shallow changes: <code>subscribe(&#39;change&#39;, callback)</code>",id:"shallow-changes-subscribechange-callback",level:4},{value:"Deep changes: <code>subscribe(&#39;changeDeep&#39;, callback)</code>",id:"deep-changes-subscribechangedeep-callback",level:4},{value:"Very specific changes: <code>subscribeToField(fieldKey, &#39;change&#39;, callback)</code>",id:"very-specific-changes-subscribetofieldfieldkey-change-callback",level:4},{value:"Entity metadata",id:"entity-metadata",level:3},{value:"uid",id:"uid",level:4},{value:"updatedAt",id:"updatedat",level:4},{value:"getSnapshot / getAll",id:"getsnapshot--getall",level:4},{value:"Schemas",id:"schemas",level:4},{value:"Authorization",id:"authorization",level:4},{value:"Types of entities",id:"types-of-entities",level:2},{value:"Object methods and properties",id:"object-methods-and-properties",level:3},{value:"List methods and properties",id:"list-methods-and-properties",level:3},{value:"File methods and properties",id:"file-methods-and-properties",level:3},{value:"Primary key",id:"primary-key",level:2}];function d(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"documents--entities",children:"Documents & Entities"})}),"\n",(0,n.jsxs)(i.p,{children:["Queries return Documents. A Document provides a ",(0,n.jsx)(i.code,{children:".get"})," method to retrieve properties, and a ",(0,n.jsx)(i.code,{children:".set"})," to set them - as well as other utility methods depending on its type. All root documents are Object Entities, which also provide ",(0,n.jsx)(i.code,{children:".update"}),". Since Documents can contain arbitrary sub-objects, you can retrieve lists off them, which comes as List Entities and provide some common list methods too."]}),"\n",(0,n.jsx)(i.p,{children:"These methods are, of course, typed based on the shape of your schema definitions!"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-ts",children:"oneDoneItem.set('done', false);\n\nanItemWithAnArrayField.get('arrayField').push('foo');\n"})}),"\n",(0,n.jsx)(i.p,{children:"These will immediately update the in-memory document across all its subscribers (Entities are also cached by identity). The change will propagate to storage and sync asynchronously. When the change is stored, the document will update and drop the in-memory changes."}),"\n",(0,n.jsx)(i.h2,{id:"universal-entity-behavior",children:"Universal Entity behavior"}),"\n",(0,n.jsx)(i.p,{children:"All Entities provide some baseline functionality, including common metadata and the ability to subscribe to changes."}),"\n",(0,n.jsx)(i.h3,{id:"subscribing-to-changes",children:"Subscribing to changes"}),"\n",(0,n.jsx)(i.p,{children:"Entities are primarily used for reactive observation of data, so naturally you want to subscribe to changes!"}),"\n",(0,n.jsx)(i.p,{children:"The Entity API contains several methods of doing this with different levels of reactive granularity. Use the one that matches your needs best."}),"\n",(0,n.jsxs)(i.h4,{id:"shallow-changes-subscribechange-callback",children:["Shallow changes: ",(0,n.jsx)(i.code,{children:"subscribe('change', callback)"})]}),"\n",(0,n.jsxs)(i.p,{children:["Calls ",(0,n.jsx)(i.code,{children:"callback"})," when any ",(0,n.jsx)(i.em,{children:"first-level"})," changes happen. Only monitors direct children of this entity. Returns an unsubscribe function."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"callback"})," is called with ",(0,n.jsx)(i.code,{children:"{ isLocal?: boolean }"}),", which will tell you if the change originated with the local replica or came from a remote source."]}),"\n",(0,n.jsxs)(i.h4,{id:"deep-changes-subscribechangedeep-callback",children:["Deep changes: ",(0,n.jsx)(i.code,{children:"subscribe('changeDeep', callback)"})]}),"\n",(0,n.jsxs)(i.p,{children:["Calls ",(0,n.jsx)(i.code,{children:"callback"})," when any ",(0,n.jsx)(i.em,{children:"deeply nested"})," changes happen. Monitors the current entity's children and downward. Returns an unsubscribe function."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"callback"})," is called with two parameters. The first is the target entity which was changed. The second is ",(0,n.jsx)(i.code,{children:"{ isLocal?: boolean }"}),", which will tell you if the change originated with the local replica or came from a remote source."]}),"\n",(0,n.jsxs)(i.p,{children:["It's worth pointing out that the target entity passed as the first parameter doesn't include much metadata that will help you identify ",(0,n.jsx)(i.em,{children:"which"})," child object it is in relation to the entity subscribed to. You will have to utilize your own logic to compare this value with children you care about. Since designing this usage initially, I have not found this parameter to be actually that helpful \ud83d\ude05."]}),"\n",(0,n.jsxs)(i.h4,{id:"very-specific-changes-subscribetofieldfieldkey-change-callback",children:["Very specific changes: ",(0,n.jsx)(i.code,{children:"subscribeToField(fieldKey, 'change', callback)"})]}),"\n",(0,n.jsxs)(i.p,{children:["Calls ",(0,n.jsx)(i.code,{children:"callback"})," whenever the referenced field of the entity changes. This is ",(0,n.jsx)(i.em,{children:"shallow"}),", it will not monitor the field for deep changes. If you need that, ",(0,n.jsx)(i.code,{children:".get"})," the field and use ",(0,n.jsx)(i.code,{children:"subscribe('changeDeep')"})," on it."]}),"\n",(0,n.jsxs)(i.p,{children:["This is really more of a convenience for monitoring primitive field changes. ",(0,n.jsx)(i.code,{children:"callback"})," will be called with two parameters: the current ",(0,n.jsx)(i.code,{children:"value"})," of the field, and an object ",(0,n.jsx)(i.code,{children:"{ isLocal?: boolean, previousValue: T }"}),", which will indicate if the change originated from the local replica or a peer, and what the prior value of the field was before the change."]}),"\n",(0,n.jsx)(i.h3,{id:"entity-metadata",children:"Entity metadata"}),"\n",(0,n.jsx)(i.h4,{id:"uid",children:"uid"}),"\n",(0,n.jsxs)(i.p,{children:["Each entity (Documents and sub-objects) has a ",(0,n.jsx)(i.code,{children:".uid"})," property, which acts as a unique key for that entity in the system. ",(0,n.jsx)(i.em,{children:"This is not the same as the primary key"})," and should be considered an opaque string. But you can use it for a React ",(0,n.jsx)(i.code,{children:"key"}),", for example. You could also use it to compare Entity identities if you want, but because Entities are cached by identity already, you can just use ",(0,n.jsx)(i.code,{children:"a === b"}),"!"]}),"\n",(0,n.jsx)(i.h4,{id:"updatedat",children:"updatedAt"}),"\n",(0,n.jsxs)(i.p,{children:["Entities automatically provide an ",(0,n.jsx)(i.code,{children:".updatedAt"})," timestamp as a Unix Epoch value, too. This timestamp is computed from the CRDT metadata. It saves you the trouble of manually tracking this with a Document field, and it's granular for each sub-object."]}),"\n",(0,n.jsx)(i.h4,{id:"getsnapshot--getall",children:"getSnapshot / getAll"}),"\n",(0,n.jsxs)(i.p,{children:["Entities provide two methods for reading all contained data. ",(0,n.jsx)(i.code,{children:"getSnapshot()"})," returns a plain Javascript object with all contained data. This is useful for deep processing of nested values, serializing data for other systems, etc. Combined with ",(0,n.jsx)(i.code,{children:"subscribe('changeDeep')"}),", you can sync plain object data to some other system, like a rich text editor or TLDraw canvas."]}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"getAll"}),", on the other hand, destructures the first layer of the Entity, but all sub-objects remain reactive Entities. You can use this similar to an object destructure to quickly read many properties on the entity at once."]}),"\n",(0,n.jsx)(i.h4,{id:"schemas",children:"Schemas"}),"\n",(0,n.jsxs)(i.p,{children:["Entities expose information about their schema configuration, according to your Verdant store schema. You can reference ",(0,n.jsx)(i.code,{children:".schema"})," to read the schema of the entity in question, or use ",(0,n.jsx)(i.code,{children:"getFieldSchema(key)"})," to get a child field's schema. I'm not sure if there's a use case for these, but they exist for internal use already, so they're exposed if you want them."]}),"\n",(0,n.jsx)(i.h4,{id:"authorization",children:"Authorization"}),"\n",(0,n.jsxs)(i.p,{children:["Entities also include ",(0,n.jsx)(i.code,{children:".isAuthorized"}),", which tells you if the Entity has authorization rules applied to it. This is kind of low-fidelity, but the way Verdant currently works you can assume this is a private entity only the current user can see if the value is ",(0,n.jsx)(i.code,{children:"true"}),". If Authorization features are developed further, this may morph into something with more information."]}),"\n",(0,n.jsx)(i.h2,{id:"types-of-entities",children:"Types of entities"}),"\n",(0,n.jsxs)(i.p,{children:["Entities currently have two shapes: ",(0,n.jsx)(i.code,{children:"Object"})," and ",(0,n.jsx)(i.code,{children:"List"}),". ",(0,n.jsx)(i.code,{children:"Object"})," covers the ",(0,n.jsx)(i.code,{children:"object"})," and ",(0,n.jsx)(i.code,{children:"map"})," field types and the root document. ",(0,n.jsx)(i.code,{children:"List"})," covers ",(0,n.jsx)(i.code,{children:"array"})," field types. ",(0,n.jsx)(i.code,{children:"List"})," entities can also be used as rudimentary Sets."]}),"\n",(0,n.jsxs)(i.p,{children:["Additionally, ",(0,n.jsx)(i.code,{children:"file"})," type fields return ",(0,n.jsx)(i.code,{children:"File"})," entities, a special type."]}),"\n",(0,n.jsx)(i.p,{children:"Each entity type exposes different fully-typed methods:"}),"\n",(0,n.jsx)(i.h3,{id:"object-methods-and-properties",children:"Object methods and properties"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"keys()"}),": Returns a list of all keys, like ",(0,n.jsx)(i.code,{children:"Object.keys"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"entries()"}),": Returns ",(0,n.jsx)(i.code,{children:"[key,value]"})," pairs, like ",(0,n.jsx)(i.code,{children:"Object.entries"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"values()"}),": Returns a list of all values, like ",(0,n.jsx)(i.code,{children:"Object.values"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"set(key, value)"}),": Sets a specific value on the entity."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"delete(key)"}),": Deletes a value by key from the entity. Only works for ",(0,n.jsx)(i.code,{children:"nullable"})," properties or on ",(0,n.jsx)(i.code,{children:"map"})," type entities."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"update(partial, { replaceSubObjects, merge })"}),": Applies a partial object value on the entity. Allows a few options for advanced usage:","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"replaceSubObjects"}),": Defaults ",(0,n.jsx)(i.code,{children:"false"}),", use ",(0,n.jsx)(i.code,{children:"true"})," to replace sub-objects by identity instead of trying to keep sub-object identity stable. Passing ",(0,n.jsx)(i.code,{children:"true"})," means if any other peer is editing a sub-object, the changes made by this ",(0,n.jsx)(i.code,{children:"update"})," will completely replace it, ignoring their changes. Use with care."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"merge"}),": Defaults ",(0,n.jsx)(i.code,{children:"true"}),", use ",(0,n.jsx)(i.code,{children:"false"})," to cause omitted keys to erase their properties. Only works if omitted keys are optional in the schema, or on ",(0,n.jsx)(i.code,{children:"map"})," type fields. Otherwise this will throw a runtime error."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"list-methods-and-properties",children:"List methods and properties"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"length"}),": Returns the length of the list, like ",(0,n.jsx)(i.code,{children:"Array.length"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"push(item)"}),": Pushes an item onto the list. Push conflicts are resolved by intent; i.e. if two pushes are concurrent both items will be added in chronological order to the end of the list."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"insert(index, item)"}),": Inserts an item at index, moving later items down. Insert conflicts are resolved by intent; i.e. if an insert is concurrent to some other change in the list, Verdant will still try to place the item at the index specified."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"move(from, to)"}),": Moves an item from one index to another, moving other items to make room for it at the destination. Move conflicts are resolved by intent; multiple moves will be applied in chronological order using whatever items are at the specified ",(0,n.jsx)(i.code,{children:"from"})," index at time of resolution. For a more stable move when the ",(0,n.jsx)(i.code,{children:"from"})," item's identity is important, use ",(0,n.jsx)(i.code,{children:"moveItem"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"moveItem(item, to)"}),": Moves the first instance of one particular item (by identity) to an index. ",(0,n.jsxs)(i.strong,{children:["If the items in this list are objects, you must pass a reference to an object retrieved from this entity, like one from ",(0,n.jsx)(i.code,{children:"get()"})]}),". Item move conflicts are resolved by intent, meaning even if the target item has moved from its original position during concurrent edits, the item will still be found and moved to the desired position. If the item is not found, nothing happens, and no error is thrown."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"add(item)"}),": A Set add method. Only pushes the item to the end of the list if it does not already exist in the list (by identity). Add conflicts are resolved by intent, meaning if two adds are concurrent, the add will not insert the item twice."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"removeAll(item)"}),": A Set remove method. Removes all instances of an item (by identity) from the list."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"has(item)"}),": A Set has method. Returns true if an item exists in the list (by identity)."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"removeFirst(item)"}),": Removes only the first instance of an item (by identity). Remove first conflicts are resolved by intent, meaning if changes are resolved between peers and a new instance of the item is found earlier in the list than when this method was called on a client, that earlier item will be removed. This only really applies to primitive lists, since by definition a list of objects can't hold two objects of the same identity."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"removeLast(item)"}),": Like ",(0,n.jsx)(i.code,{children:"removeFirst"}),", but from the opposite end."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"map(callback)"}),": Does not modify the list. Lets you map over the items in the list and transform them. Returns a new JS ",(0,n.jsx)(i.code,{children:"Array"})," with the mapped items (not a new List entity). Similar to ",(0,n.jsx)(i.code,{children:"Array.map"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"filter(callback)"}),": Does not modify the list. Lets you filter items to a subset. Returns a new JS ",(0,n.jsx)(i.code,{children:"Array"})," with the filtered items (not a new List entity). Similar to ",(0,n.jsx)(i.code,{children:"Array.filter"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"delete(index)"}),": Deletes an item from the list by index. The item at the index is removed, and other items shift to 'fill the space.' Similar to ",(0,n.jsx)(i.code,{children:"Array.splice(index, 1)"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"forEach(callback)"}),": Invokes the callback with each item in the list. Similar to ",(0,n.jsx)(i.code,{children:"Array.forEach"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"some(callback)"}),": Returns ",(0,n.jsx)(i.code,{children:"true"})," if any item in the list passes the predicate (the callback returns ",(0,n.jsx)(i.code,{children:"true"}),"). Similar to ",(0,n.jsx)(i.code,{children:"Array.some"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"every(callback)"}),": Returns ",(0,n.jsx)(i.code,{children:"true"})," if every item in the list passes the predicate (the callback returns ",(0,n.jsx)(i.code,{children:"true"}),"). Similar to ",(0,n.jsx)(i.code,{children:"Array.every"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"find(callback)"}),": Returns the first item in the list that passes the predicate (the callback returns ",(0,n.jsx)(i.code,{children:"true"}),"). Similar to ",(0,n.jsx)(i.code,{children:"Array.find"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"includes(item)"}),": Alias of ",(0,n.jsx)(i.code,{children:"has"}),", to align with ",(0,n.jsx)(i.code,{children:"Array.includes"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(i.p,{children:["Additionally, List entities implement ",(0,n.jsx)(i.code,{children:"Iterable"}),", so you can use them in ",(0,n.jsx)(i.code,{children:"for...of"})," loops."]}),"\n",(0,n.jsx)(i.h3,{id:"file-methods-and-properties",children:"File methods and properties"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"url"}),": Either a ",(0,n.jsx)(i.code,{children:"string"})," URL for the file, or ",(0,n.jsx)(i.code,{children:"null"})," if the file is not available for any reason (loading or error)"]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"name"}),": The filename, as recorded when it was created. May be ",(0,n.jsx)(i.code,{children:"null"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"type"}),": The file mimetype as recorded when it was created. May be ",(0,n.jsx)(i.code,{children:"null"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"loading"}),": True if the file is still being fetched."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"failed"}),": True if the file failed to load."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"isUploaded"}),": True if the file has been uploaded to a sync server."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"isFile"}),": always true."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.code,{children:"getSnapshot()"}),": Returns a plain object with metadata about the current state of the file. Includes ",(0,n.jsx)(i.code,{children:"url"}),", ",(0,n.jsx)(i.code,{children:"name"}),", ",(0,n.jsx)(i.code,{children:"remote"})," (is the file uploaded to the server?), ",(0,n.jsx)(i.code,{children:"type"}),", and ",(0,n.jsx)(i.code,{children:"file"})," (the literal File blob, if available)."]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"primary-key",children:"Primary key"}),"\n",(0,n.jsxs)(i.p,{children:["Every document has a primary key, which identifies it throughout the Verdant system. This primary key cannot be changed. Right now the types on documents will accept the primary key in a ",(0,n.jsx)(i.code,{children:".set"})," or ",(0,n.jsx)(i.code,{children:".update"}),", but will throw an error at runtime if it's used. In the future hopefully I'll update the types to make this constraint easier to catch while coding."]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8576:(e,i,t)=>{t.d(i,{R:()=>l,x:()=>o});var s=t(3917);const n={},r=s.createContext(n);function l(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);