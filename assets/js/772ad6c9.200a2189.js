"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5280],{5903:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"sync/pruning","title":"Pruning Invalid Data","description":"Verdant has a lot of tricks up its sleeve for providing strong schema support while still making sure the data your app sees stays consistent, even when some peers haven\'t updated their app yet.","source":"@site/docs/sync/pruning.md","sourceDirName":"sync","slug":"/sync/pruning","permalink":"/docs/sync/pruning","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Synchronizing files","permalink":"/docs/sync/files"},"next":{"title":"Server Persistent Storage","permalink":"/docs/sync/storage"}}');var i=t(7557),o=t(6039);const a={sidebar_position:8},r="Pruning Invalid Data",l={},d=[{value:"Pruning",id:"pruning",level:2},{value:"What you need to know",id:"what-you-need-to-know",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"pruning-invalid-data",children:"Pruning Invalid Data"})}),"\n",(0,i.jsx)(n.p,{children:"Verdant has a lot of tricks up its sleeve for providing strong schema support while still making sure the data your app sees stays consistent, even when some peers haven't updated their app yet."}),"\n",(0,i.jsxs)(n.p,{children:["But this only goes so far. When I first designed the ",(0,i.jsx)(n.a,{href:"/docs/local-storage/migrations",children:"migration"})," system, I felt it was solid enough to ship, but I always worried there were edge cases. Turns out there are, and it took me over a year of using Verdant in production to discover them!"]}),"\n",(0,i.jsx)(n.p,{children:'The main problem is this: say you migrate your schema in a backwards-incompatible way, and a client connects and migrates. Now suppose another peer was online a little while ago, or is even online now using the old version, and they pushed some changes up to the server. This new, migrated client will still get those "old version" changes. Those changes could potentially include setting particular fields to values which are now invalid for the new schema.'}),"\n",(0,i.jsxs)(n.p,{children:["Got it? You can skip the next bit and go on to how ",(0,i.jsx)(n.a,{href:"#pruning",children:"pruning works"})]}),"\n",(0,i.jsx)(n.p,{children:"It's easier to see in an example..."}),"\n",(0,i.jsxs)(n.p,{children:["Let's say your ",(0,i.jsx)(n.code,{children:"comments"})," field used to be a list of strings:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"comments: {\n  type: 'array',\n  items: { type: 'string' }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And your new version changes it to a list of objects with ",(0,i.jsx)(n.code,{children:"body"})," properties:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"comments: {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      body: { type: 'string' }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You would need to write a migration which converts existing data into the new shape, of course:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"createMigration(v1Schema, v2Schema, async ({ migrate }) => {\n\tawait migrate('posts', ({ comments, ...old }) => ({\n\t\t...old,\n\t\tcomments: comments.map((body) => ({ body })),\n\t}));\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["So what's the problem? Well, the migration only runs when the client starts up. And, in fact, it runs ",(0,i.jsx)(n.em,{children:"before"})," the client syncs with the server, by design. Which means when migrating, we only see any comments we already know about."]}),"\n",(0,i.jsxs)(n.p,{children:["But then let's say we sync with the server and someone has ",(0,i.jsx)(n.code,{children:"push"}),'ed a new comment to the comments list. We will get a sync message from the server like: "push ',(0,i.jsx)(n.code,{children:'"hello world"'})," onto list ",(0,i.jsx)(n.code,{children:"comments"}),'." Only our ',(0,i.jsx)(n.code,{children:"comments"})," isn't a list of strings anymore!"]}),"\n",(0,i.jsxs)(n.p,{children:["Other distributed systems solve this problem in very clever ways, like ",(0,i.jsx)(n.a,{href:"https://www.inkandswitch.com/cambria/",children:"Ink and Switch's inspiring Project Cambria"}),' which uses "lenses" into data, rather than one-time migrations like Verdant. But these systems have costs, both in runtime and overall system complexity, which I don\'t feel confident trying to balance.']}),"\n",(0,i.jsx)(n.p,{children:"More systems instead force you to make only backwards-compatible schema changes, like only adding fields, and always making object relationships nullable. And that's fine, but I find that very limiting and tedious. I really like the idea of being able to rename or delete fields--otherwise naming becomes more obscure and awkward over time."}),"\n",(0,i.jsxs)(n.p,{children:["So here's my compromise: Verdant does something called ",(0,i.jsx)(n.strong,{children:"pruning"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"pruning",children:"Pruning"}),"\n",(0,i.jsx)(n.p,{children:'Verdant documents will scan their data whenever it changes and identify if any sub-field is invalid according to the schema. If invalid sub-fields are detected, Verdant figures out how to "prune" them while retaining the correct document shape.'}),"\n",(0,i.jsxs)(n.p,{children:["If the field is nullable, it becomes ",(0,i.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"If the field has a default, it uses the default."}),"\n",(0,i.jsxs)(n.p,{children:["If the field is an ",(0,i.jsx)(n.code,{children:"array"})," or ",(0,i.jsx)(n.code,{children:"map"})," type, it becomes empty (don't worry, this only happens if the actual underlying datatype is incompatible - like if you changed a field type from ",(0,i.jsx)(n.code,{children:"object"})," to ",(0,i.jsx)(n.code,{children:"array"}),", something drastic like that)."]}),"\n",(0,i.jsx)(n.p,{children:"Otherwise, the invalid-ness bubbles upward to the parent field, and the cycle continues."}),"\n",(0,i.jsxs)(n.p,{children:["If there's a chain of fields which can't be ",(0,i.jsx)(n.code,{children:"null"}),"ed or defaulted that contain invalid data all the way up to the root of the document, the document itself is pruned--it becomes inaccessible, similar to if it were deleted."]}),"\n",(0,i.jsx)(n.h2,{id:"what-you-need-to-know",children:"What you need to know"}),"\n",(0,i.jsx)(n.p,{children:"The end result of pruning is that you can opt-in to a safer schema design by following the practices of other systems: add-only schemas, nullable fields, etc. Or, if you feel confident your schema design won't change much in some places, you can make them more strict as you like."}),"\n",(0,i.jsx)(n.p,{children:"There are some things you want to be careful about when changing your schema:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Changing the shape of list or map items:"})," Items added by other clients may not appear on newer peers until those clients upgrade themselves."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Creating things if they aren't found:"})," If your app has logic which checks if a nullable field exists, and otherwise adds something there, it may accidentally overwrite pruned data. Working around this will depend on your situation."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},6039:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(8225);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);