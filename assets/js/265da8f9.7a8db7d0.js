"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8460],{3247:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"sync/cloudflare","title":"Cloudflare Adapter","description":"Verdant supports Cloudflare as a sync platform. Setting up a Cloudflare-based server is significantly different from a Node server, but has a big advantage: Verdant libraries are represented by Durable Objects, so your app can scale horizontally to any number of libraries without maintaining servers. You can also more easily take advantage of the on-demand nature of serverless.","source":"@site/docs/sync/cloudflare.md","sourceDirName":"sync","slug":"/sync/cloudflare","permalink":"/docs/sync/cloudflare","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12},"sidebar":"tutorialSidebar","previous":{"title":"Tips and tricks for working in distributed systems","permalink":"/docs/sync/tips-and-tricks"},"next":{"title":"CLI","permalink":"/docs/cli"}}');var o=n(1273),a=n(8576);const s={sidebar_position:12},i="Cloudflare Adapter",c={},d=[{value:"Using the Durable Object binding",id:"using-the-durable-object-binding",level:2}];function l(t){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"cloudflare-adapter",children:"Cloudflare Adapter"})}),"\n",(0,o.jsx)(e.p,{children:"Verdant supports Cloudflare as a sync platform. Setting up a Cloudflare-based server is significantly different from a Node server, but has a big advantage: Verdant libraries are represented by Durable Objects, so your app can scale horizontally to any number of libraries without maintaining servers. You can also more easily take advantage of the on-demand nature of serverless."}),"\n",(0,o.jsx)(e.p,{children:"Here's the boilerplate for setting up Cloudflare bindings:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"import { createVerdantWorkerApp, R2FileStorage, DurableObjectLibrary } from '@verdant-web/cloudflare';\nimport { errorHandler } from '@verdant-web/server/hono';\nimport { Hono } from 'hono';\n\nexport class VerdantLibrary extends DurableObject {\n\tprivate verdant: DurableObjectLibrary;\n\n\tconstructor(ctx: DurableObjectState, env: any) {\n\t\tsuper(ctx, env);\n\t\tthis.verdant = new VerdantObject(ctx, {\n\t\t\ttokenSecret: env.TOKEN_SECRET,\n\t\t\t// verdant also has an s3 storage you can use\n\t\t\tfileStorage: new R2FileStorage({\n\t\t\t\thost: `https://my-deployed.app/files`,\n\t\t\t\tbucket: env.VERDANT_BUCKET,\n\t\t\t}),\n\t\t\tprofiles: {\n\t\t\t\tget: async (id) => {\n\t\t\t\t\treturn env.YOUR_D1_DB.prepare(`SELECT * FROM User WHERE id = ?`).bind(id).first();\n\t\t\t\t},\n\t\t\t},\n\t\t\tlog: (level, ...args) => {\n\t\t\t\t// log if you like.\n\t\t\t}\n\t\t});\n\t}\n\n\t// these methods are REQUIRED!\n\tfetch(request: Request) {\n\t\treturn this.verdant.fetch(request);\n\t}\n\twebSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {\n\t\treturn this.verdant.webSocketMessage(ws, message);\n\t}\n\twebSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {\n\t\treturn this.verdant.webSocketClose(ws, code, reason, wasClean);\n\t}\n\twebSocketError(ws: WebSocket, error: Error) {\n\t\treturn this.verdant.webSocketError(ws, error);\n\t}\n\n\t// you're free to define more, including exposing\n\t// library APIs\n\tgetDocumentSnapshot(collection: string, id: string) {\n\t\treturn this.verdant.getDocumentSnapshot(collection, id);\n\t}\n}\n\nconst verdantRouter = createVerdantWorkerApp({\n\tdurableObjectBindingName: 'VERDANT_LIBRARY',\n\ttokenSecretBindingName: 'TOKEN_SECRET',\n});\n\nexport default new Hono<{ Bindings: Env }>()\n\t// you can bind the Verdant API to any subpath you like\n\t.route('/verdant', verdantRouter)\n\t// it's recommended, but not required, to define the rest of\n\t// your own server API here to set up auth and serve user files.\n\t.get('/auth/:library', async (ctx) => {\n\t\tconst library = ctx.req.param('library');\n\t\t// TODO: you write logic to authenticate and retrieve your user session\n\t\t// and make sure they are allowed to sync this library\n\t\tconst session = ...;\n\t\tconst tokenProvider = new TokenProvider({ secret: ctx.env.TOKEN_SECRET });\n\t\tconst token = tokenProvider.getToken({\n\t\t\tlibraryId: library,\n\t\t\tuserId: session.userId,\n\t\t\t// point to your verdant API router subpath\n\t\t\tsyncEndpoint: `https://my-deployed.app/verdant`,\n\t\t});\n\t\t// this payload shape is important.\n\t\treturn ctx.json({ accessToken: token });\n\t})\n\t// NOTE: serving files via your worker is optional, even for R2 storage.\n\t// You could also set up a custom domain for your bucket with\n\t// public access, and configure R2FileStorage with that domain instead.\n\t.get('/files/*', async (ctx) => {\n\t\tconst path = ctx.req.path.replace(/^/files\\//, '');\n\t\t// retrieving the actual file from our R2 bucket\n\t\tconst obj = await ctx.env.VERDANT_BUCKET.get(path);\n\t\tif (!obj?.body) {\n\t\t\treturn ctx.text('not found', 404);\n\t\t}\n\t\treturn new Response(obj.body, {\n\t\t\theaders: {\n\t\t\t\t'Content-Type':\n\t\t\t\t\tobj.httpMetadata?.contentType ?? 'application/octet-stream'\n\t\t\t}\n\t\t})\n\t})\n"})}),"\n",(0,o.jsx)(e.h2,{id:"using-the-durable-object-binding",children:"Using the Durable Object binding"}),"\n",(0,o.jsx)(e.p,{children:"This library exports a Library API representation you compose into your own defined Durable Object, at least for now. This avoids some weird behavior with DurableObject subclassing and generally favors composition over inheritance. You are free to customize the actual invocation of this underlying library API withing your DO, but you should make sure the right methods end up getting called or it won't work."}),"\n",(0,o.jsxs)(e.p,{children:["You can access a library's Durable Object directly by calling ",(0,o.jsx)(e.code,{children:"getByName(libraryId)"}),". Internally, ",(0,o.jsx)(e.code,{children:"createVerdantWorkerApp"})," does this the same way."]}),"\n",(0,o.jsxs)(e.p,{children:["One quirk of how the DO lifecycle works is that the library won't be initialized until the first Verdant client connects and seeds the Library's ID. If you try to access and call RPC methods on your DO without first handling a ",(0,o.jsx)(e.code,{children:"fetch"})," request, things may or may not work as expected."]}),"\n",(0,o.jsxs)(e.p,{children:["If you want to use or manipulate a library before any clients connect (I can't think of a reason for this, but anyway), call ",(0,o.jsx)(e.code,{children:".initialize(libraryId)"})," first with its library ID. It might seem intuitive that the DO you got access to by passing the library ID to ",(0,o.jsx)(e.code,{children:"getByName"})," would know its own ID already, but it won't if it's never been used, because the \"name\" of a DO is not exposed to it."]})]})}function u(t={}){const{wrapper:e}={...(0,a.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(l,{...t})}):l(t)}},8576:(t,e,n)=>{n.d(e,{R:()=>s,x:()=>i});var r=n(3917);const o={},a=r.createContext(o);function s(t){const e=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function i(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:s(t.components),r.createElement(a.Provider,{value:e},t.children)}}}]);